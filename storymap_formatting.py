import arcpy
import os
import zipfile

arcpy.CheckOutExtension("Spatial")
arcpy.env.overwriteOutput = True
arcpy.env.qualifiedFieldNames = False

#Folder structure
rootdir = 'C:/Mathis/ICSL/flood_vulnerability'
datadir = os.path.join(rootdir, 'data')
resdir = os.path.join(rootdir, 'results')
gdb = os.path.join(resdir,'flood_risk.gdb')
storydir = os.path.join(resdir, 'storymap')
tract_floodfinal = os.path.join(gdb, 'tracts_floodfinal')
floodboolpoly = os.path.join(gdb,'def1in100_45_boolproj')
parcel_flood_attri = os.path.join(gdb, 'parcel_blocks_fill_flood_attri')

if not arcpy.Exists(storydir):
    os.mkdir(storydir)
arcpy.env.workspace = storydir

#From http://emilsarcpython.blogspot.com/2015/10/zipping-shapefiles-with-python.html
def ZipShp(inShp, Delete=True):
    """
    Creates a zip file containing the input shapefile
    inputs -
    inShp: Full path to shapefile to be zipped
    Delete: Set to True to delete shapefile files after zip
    """

    # List of shapefile file extensions
    extensions = [".shp",
                  ".shx",
                  ".dbf",
                  ".sbn",
                  ".sbx",
                  ".fbn",
                  ".fbx",
                  ".ain",
                  ".aih",
                  ".atx",
                  ".ixs",
                  ".mxs",
                  ".prj",
                  ".xml",
                  ".cpg"]

    # Directory of shapefile
    inLocation = arcpy.Describe(inShp).path
    # Base name of shapefile
    inName = arcpy.Describe(inShp).baseName
    # Create zipfile name
    zipfl = os.path.join(inLocation, inName + ".zip")
    # Create zipfile object
    ZIP = zipfile.ZipFile(zipfl, "w")

    # Iterate files in shapefile directory
    for fl in os.listdir(inLocation):
        # Iterate extensions
        for extension in extensions:
            # Check if file is shapefile file
            if fl == inName + extension:
                # Get full path of file
                inFile = os.path.join(inLocation, fl)
                # Add file to zipfile
                ZIP.write(inFile, fl)
                break

    # Delete shapefile if indicated
    if Delete == True:
        arcpy.Delete_management(inShp)

    # Close zipfile object
    ZIP.close()

    # Return zipfile full path
    return zipfl


arcpy.SimplifyPolygon_cartography(floodboolpoly, 'def1in100_45_boolpoly_simpl.shp', algorithm = 'BEND_SIMPLIFY',
                                  tolerance = '20 meters', collapsed_point_option = 'NO_KEEP')

#Create tile layers
arcpy.CreateMapTilePackage_management(floodboolpoly, ...) #FATHOM flood zone
arcpy.CreateMapTilePackage_management('parceltile.mxd',
                                      service_type = 'ONLINE',
                                      output_file = os.path.split(parcel_flood_attri)[1] + '_tile',
                                      format_type = 'PNG', level_of_detail = 20) #Parcel dataset



#Add fields to census tracts computing number of residents living within flood zone for each race/ethnicity
nflist = ['tract_{}_floodpop'.format(i) for i in ['hisp', 'black', 'white', 'asi']]
for nf in nflist:
    print(nf)
    if nf not in [f.name for f in arcpy.ListFields(tract_floodfinal)]:
        arcpy.AddField_management(tract_floodfinal, nf, 'SHORT')

cursorfields = nflist + ['SUM_FLOODPOP_B', 'DP0110001', 'DP0110002', 'DP0110012', 'DP0110011', 'DP0110014', 'DP0110015']
with arcpy.da.UpdateCursor(tract_floodfinal, cursorfields) as cursor:
    for row in cursor:
        if row[5]>0:
            row[0] = row[4] * row[6] / row[5] #e.g. tract_hisp_floodpop = number of people in flood zone * number of hispanics(DP0110002)/total pop (DP0110001)
            row[1] = row[4] * row[7] / row[5]
            row[2] = row[4] * row[8] / row[5]
            row[3] = row[4] * (row[9] + row[10]) / row[5]
        else:
            row[0] = 0
            row[1] = 0
            row[2] = 0
            row[3] = 0
        cursor.updateRow(row)

#Compute percentage population based on tract-level assessment in flood zone
arcpy.AddField_management(tract_floodfinal, 'tract_floodper', 'FLOAT')
arcpy.CalculateField_management(tract_floodfinal, 'tract_floodper', expression = '!SUM_FLOODPOP_B!/!SUM_POP10!',
                                expression_type='PYTHON')
arcpy.CopyFeatures_management(tract_floodfinal, 'tracts_floodfinal.shp')
ZipShp('tracts_floodfinal.shp', Delete = True)