"""
Author: Mathis L. Messager
Affiliation: School of Environmental and Forest Sciences, University of Washington
Contact info: messamat@uw.edu
Date created: August 2019

Purpose: Cleans, formats, and parses residential land owner names from the Washington State parcel database collated by
the UW Rural Technology Initiative (RTI).
"""

import arcpy
import os
import sys
import re
from collections import defaultdict

arcpy.env.qualifiedFieldNames = False
arcpy.env.overwriteOutput = True

#Folder structure
rootdir = os.path.dirname(os.path.abspath(__file__)).split('\\src')[0]
datadir = os.path.join(rootdir,'data\\')
resdir = os.path.join(rootdir,'results\\')

gdb = os.path.join(resdir,'flood_vulnerability.gdb')
if arcpy.Exists(gdb):
    print('Geodatabase already exists')
else:
    arcpy.CreateFileGDB_management(resdir, 'flood_vulnerability.gdb')
arcpy.env.workspace = gdb

#--------------------------------------------------------------------
# Import data (see data/metadata.xls) and set up variables
#--------------------------------------------------------------------
WAdb = os.path.join(datadir, 'WAParcel\StatewideParcels_v2012_e9.2_r1.3\StatewideParcels_v2012_e9.2_r1.3.gdb')#Washington statewide parcel database gdb
parcel = os.path.join(WAdb, 'Land\Parcel')
parcel_name = os.path.join(WAdb, 'Name')
parcel_taxroll = os.path.join(WAdb, 'TaxRoll')
parcel_taxrollname_r = os.path.join(WAdb, 'TaxRollsHaveNames')
StateLU =  os.path.join(WAdb, 'StateLandUse')
provider = os.path.join(WAdb, 'DataProvider')

#Common variables
resid = 'parcel_taxrollname_residential'
resid_nonull = 'parcel_taxrollname_residential_nonull'
resid_indiv = 'parcel_taxrollname_residindiv'
parcel_taxrollname_rclean = 'TaxRollsHaveNames_sortclean'

#Set up variable
#Create list of data providers code
providerID = {}
for row in arcpy.da.SearchCursor(provider, ['DataProviderID','Name']):
    providerID[row[0]] = row[1]

#-----------------------------------------------------------
# Define functions
#-----------------------------------------------------------
def pattern_word(word, plural):
    """Converts an input string into a regex-formatted word string"""
    if isinstance(word, str):
        #rword = re.escape(word)
        if plural is True:
            reg_word = r'\b' + word + r'S?\b'
        else:
            reg_word = r'\b' + word + r'\b'
        return reg_word
    else:
        raise Warning('input is not a string')

def pattern_abbrev(word):
    """Converts an input string into a regex-formatted word string with a period at the end, as in an abbreviation"""
    if isinstance(word, str):
        #rword = re.escape(word)
        reg_word = r'\b' + word + r'\b[.]?'
        return reg_word
    else:
        raise Warning('input is not a string')
def pattern_acronym(word):
    """Converts a series of letters into a regex-formatted acronym"""
    if isinstance(word, str):
        #rword = re.escape(word)
        reg_word = r'(^|\s)'+r'\W?'.join([i for i in word])+'([.]?[*]?\s*|\/)(\s|$)'
        return reg_word
    else:
        raise Warning('input is not a string')

def delete_empty_fields(fc, fieldlist):
    """Delete fields with only nulls, None, spaces, etc. within a provided list of fields
    Adapted from https://gis.stackexchange.com/questions/204684/delete-empty-and-null-fields-using-arcpy"""
    for field in fieldlist:
        print(field)
        keep = False
        for row in arcpy.da.UpdateCursor(fc, [field]):
            if row[0] is not None or \
                    (isinstance(row[0], basestring) and\
                     (row[0].lower.strip() != '' or\
                           row[0] != '<null>')):
                keep = True
                break
        if keep is False:
            print('Deleting: '+field)
            arcpy.DeleteField_management(fc, field)

def regex_field_split(fc, splitfield, regx, maxsplit, field_keyword):
    "Split a field into multiple fields based on a regular expression, the equivalent of panda.str.split() with arcpy cursor"
    party_fieldlist = ['{0}{1}'.format(field_keyword, i) for i in range(1,maxsplit+1)] #Fields to split string among
    for field in party_fieldlist: #create fields
        if field not in [f.name for f in arcpy.ListFields(fc)]: #first make sure it's not really there, skip if it is
            arcpy.AddField_management(fc, field, field_type='text')
    regex_letter = re.compile(r'[A-Z]',re.IGNORECASE)
    with arcpy.da.UpdateCursor(fc, [splitfield]+party_fieldlist) as cursor:
        for row in cursor: #For each row
            if regex_letter.search(row[0]) is not None: #Make sure that cell is not empty
                #print(row[0])
                splitparty = regx.split(row[0], maxsplit) #Split cell based on regex pattern
                f=1
                for i in range(len(splitparty)): #Add each substring to a separate field, removing leading and trailing spaces
                    if regex_letter.search(splitparty[i]) is not None: #Make sure that the field is not empty
                        row[f]=splitparty[i].strip()
                        f=f+1
                cursor.updateRow(row)
            else:
                cursor.deleteRow() #If cell is empty, delete row (special application for owner names)
    delete_empty_fields(fc, party_fieldlist) #Remove new fields that didn't get filled

def regex_field_extract(fc, targetfield_regx, newfield_keyword, regx, minwords=0):
    '''Extract substrings from fields and writes them to other fields.
    Specifically, takes a regex to match fields from which to extract keywords based on another regex, write the keywords
    to a new field, and then remove these keywords from the original field. For instance, can remove JR from Donald Trump JR'''
    fullword_regx = re.compile(r"\b[A-Z]+[']?[-]?[A-Z]+\b", re.IGNORECASE) #Define full word as at two letters possibly separated by apostrophe and/or hypehn
    mainkeyfields = [f.name for f in arcpy.ListFields(fc) if targetfield_regx.search(f.name)]  # List of fields to extract from
    for field in mainkeyfields:  #For each substring
        field_suffix = '{0}_{1}'.format(field, newfield_keyword) #name of new field
        arcpy.AddField_management(fc, field_suffix, field_type='text') #Create new field
        with arcpy.da.UpdateCursor(fc, [field, field_suffix]) as cursor:
            for row in cursor:  # For each row
                #print(row[0])
                try:
                    if minwords > 0: #If there is a minimum number of full words (> 1 letter) required to extract
                        fullwords = fullword_regx.findall(row[0]) #Get the number of full words in field
                        if len(fullwords) >= minwords:
                            suffix_search = regx.findall(row[0]) #Get all keyword matches in a list
                            if suffix_search: #If list is not empty (i.e. there is a keyword in subparty name)
                                row[1]= ','.join(suffix_search) #Write matched keywords to new field
                                row[0]=regx.sub('', row[0]).strip() #Remove keyword from original field to clear it up for future steps
                                cursor.updateRow(row)
                    else:
                        suffix_search = regx.findall(row[0])  # Get all keyword matches in a list
                        if suffix_search:  # If list is not empty (i.e. there is a keyword in subparty name)
                            row[1] = ','.join(suffix_search)  # Write matched keywords to new field
                            row[0] = regx.sub('', row[
                                0]).strip()  # Remove keyword from original subparty name to clear it up for future steps
                            cursor.updateRow(row)
                except:
                    e = sys.exc_info()[1]
                    #print(e.args[0])
    delete_empty_fields(fc, ['{0}_{1}'.format(field, newfield_keyword) for field in mainkeyfields]) #Delete empty keyword fields

def regex_delete(fc, targetfield_regx, regx):
    """Remove regx pattern from fields recognized by regx"""
    mainkeyfields = [f.name for f in arcpy.ListFields(fc) if targetfield_regx.search(f.name)]  # List of fields to delete pattern from
    for field in mainkeyfields:  # For each target field (e.g. land parcel owning party)
        with arcpy.da.UpdateCursor(fc, [field]) as cursor:
            for row in cursor:  # For each row
                # print(row[0])
                try:
                        row[0] = regx.sub('', row[0]).strip()  # Remove pattern from cell and spaces surrounding output string
                        cursor.updateRow(row)
                except:
                    e = sys.exc_info()[1]
                    # print(e.args[0])

#----------------------------------------------------------
# CLEAN DUPLICATE TAXROLL RECORDS
#----------------------------------------------------------
"""
Some counties have provided owner names for land parcels, others have provided taxpayer name, and yet others have provided
both owner and taxpayer names. 
- If both owner and taxpayer names have been provided, only keep owner name. 
- If two different owner/taxpayer name records have been provided for the same property, add to a list of duplicates
"""
reclist = defaultdict(list)
duplilist = defaultdict(list)
arcpy.Sort_management(parcel_taxrollname_r, parcel_taxrollname_r+'_sort', sort_field='NameRole')
arcpy.CopyRows_management(parcel_taxrollname_r+'_sort', parcel_taxrollname_rclean)
with arcpy.da.UpdateCursor(parcel_taxrollname_rclean, ['TaxRollID','NameRole','OBJECTID']) as cursor:
    for row in cursor:
        #if (row[2] % 1000)==0:
        #print(row[2])
        if row[0] in reclist:
            if row[1]=='Taxpayer' and reclist[row[0]][0]=='Owner':
                cursor.deleteRow()
                print('Deleted')
            if row[1] == 'Owner' and reclist[row[0]][0] == 'Owner':
                duplilist[row[0]]=[row[1],row[2]]
            if row[1] == 'Taxpayer' and reclist[row[0]][0] == 'Taxpayer':
                duplilist[row[0]]=[row[1],row[2]]
        else:
            reclist[row[0]]=[row[1],row[2]]

"""
Check remaining duplicate TaxRollIDs as these mean that a single property is associated with two different names and addresses 
(or a duplicate record of the same name and address)
- Keep the record with the most non-null fields. 
- If # non-full fields is equal, keep record with higher ProcessNameFlattened #
- If ProcessNameFlattened # is equal, keep first record

First create dictionary of records to keep and remove, then delete those in the latter.
"""
SQLsel = '"TaxRollID" IN {}'.format(str(tuple([k.encode('ascii','ignore') for k in duplilist.keys()]))) #Create SQL expression to select duplicate records
arcpy.MakeTableView_management(parcel_taxrollname_rclean, parcel_taxrollname_rclean+'_lyr', SQLsel)
arcpy.AddJoin_management(parcel_taxrollname_rclean+'_lyr','NameID',parcel_name,'NameID')
arcpy.CopyRows_management(parcel_taxrollname_rclean+'_lyr', parcel_taxrollname_rclean+'_dupliTaxRollID')
#Field indices: TaxRollID=2, NameID=3, ProcessNameFlattened=-2
taxrollkeep = defaultdict(list)
taxrollremove = defaultdict(list)
with arcpy.da.SearchCursor(parcel_taxrollname_rclean+'_dupliTaxRollID', ['*']) as cursor:
    for row in cursor:
        fcount = len([f for f in row if f is not None])  # Count number of fields that are not Null
        if row[2] not in taxrollkeep: #If taxrollID not already in dic
            taxrollkeep[row[2]]=[row[3],fcount,row[-2]] #add NameID, # of non-null fields, and ProcessNameFlattened to dic
        else: #If already a record for taxrollID in dic
            if fcount>taxrollkeep[row[2]][1]:  #If more non-null fields
                taxrollremove[row[2]].append([taxrollkeep[row[2]][0], taxrollkeep[row[2]][2]]) #Transfer existing NameID and ProcessNameFlattened in taxrollkeep to taxrollremove
                taxrollkeep[row[2]] = [row[3], fcount, row[-2]] #Add current record to taxrollkeep
            elif row[-2]>taxrollkeep[row[2]][2]:  #If higher ProcessNameFlattened
                taxrollremove[row[2]].append([taxrollkeep[row[2]][0], taxrollkeep[row[2]][2]]) #Transfer existing NameID and ProcessNameFlattened in taxrollkeep to taxrollremove
                taxrollkeep[row[2]] = [row[3], fcount, row[-2]] #Add current record to taxrollkeep
            else: #If same number of non-null fields and ProcessNameFlattened
                taxrollremove[row[2]].append([row[3], row[-2]])

with arcpy.da.UpdateCursor(parcel_taxrollname_rclean, ['TaxRollID','NameID']) as cursor:
    for row in cursor:
        if row[0] in taxrollremove:
            if row[1] in [v[0] for v in taxrollremove[row[0]]]:
                cursor.deleteRow()

#-------------------------------------------------------------------------------------------------
# JOIN AND FILTER OUT TAXROLL RECORDS TO KEEP ONLY RESIDENTIAL PARCELS WITH OWNER NAMES
#-------------------------------------------------------------------------------------------------
#Join taxroll record to owner names
arcpy.MakeTableView_management(parcel_taxroll, 'parcel_taxroll_lyr')
arcpy.AddJoin_management('parcel_taxroll_lyr','TaxRollID',parcel_taxrollname_rclean,'TaxRollID', join_type='KEEP_COMMON')
arcpy.AddJoin_management('parcel_taxroll_lyr',parcel_taxrollname_rclean+'.NameID',parcel_name,'NameID')
arcpy.CopyRows_management('parcel_taxroll_lyr', 'parcel_taxrollname')

#Identify residential land use codes, excluding vacation and hotels
arcpy.Exists(StateLU)
arcpy.MakeTableView_management(StateLU, 'StateLU_lyr', where_clause="Category='RESIDENTIAL'")
LUsel = {}
for row in arcpy.da.SearchCursor('StateLU_lyr',['StateLandUseCD','Name']):
    print(row[0])
    if row[1] not in ['Vacation and cabin','Hotels/motels']:
        LUsel[row[0]]=row[1]

#Only keep residential parcels
#[f.name for f in arcpy.ListFields('parcel_taxrollname')]
arcpy.MakeTableView_management('parcel_taxrollname', 'parcel_taxrollname_lyr')
SQLsel = '"StateLandUseCD" IN ({})'.format(', '.join(map(str, LUsel.keys())) or 'NULL')
arcpy.SelectLayerByAttribute_management('parcel_taxrollname_lyr', 'NEW_SELECTION', SQLsel)
arcpy.CopyRows_management('parcel_taxrollname_lyr', resid)

#Remove all records with no owner name
arcpy.SelectLayerByAttribute_management('parcel_taxrollname_lyr', 'SUBSET_SELECTION', 'NOT "Name" IS NULL')
arcpy.CopyRows_management('parcel_taxrollname_lyr', resid_nonull)
#Check records with no owner name
arcpy.SelectLayerByAttribute_management('parcel_taxrollname_lyr', 'SUBSET_SELECTION', '"Name" IS NULL')
arcpy.CopyRows_management('parcel_taxrollname_lyr', resid+'_null')
#pd.DataFrame(arcpy.da.TableToNumPyArray(resid, '*', skip_nulls=False, null_value=-99999)) #insufficient memory

#------------------------------------------------------------------------------------------------------
# CLEAN UP AND FORMAT NAMES FOR PARSING
#------------------------------------------------------------------------------------------------------
#Only keep individual owners rather than companies or institutions. If doesn't work, try: https://github.com/datamade/probablepeople
print('Processing: remove non-individuals')
#COMPANIES#
#Assign company names to word categories to be converted to regex pattern
private_words = ['ENTERPRISE','SHARE','COMPANY','PARTNER', 'PARTNERSHIP','PRTNRSHP','PRTNRSP','PTRN','PRTN','PTNSHP','CORPORATION',
                 'MORTGAGE','INVESTMENT','INVES[a-zA-Z]*','ASSOCIATE','ACQUISITION','RESEARCH','BROKERAGE','COMPANY',
                 'CONSULTING','CONSULTANT','REALTY','ORGANIZATION','GROUP','SERVICE','PROPERTY','APT','MANAGEMENT',
                 'APARTMENT','CONDOMINIUM','RESIDENTIAL','PROPERT[a-zA-Z]*','LIFE\s?EST','LF\s?EST','ESTATE',
                 'RANCH[ES]*','HOLDING','CAPITAL','FUND','SUBSIDIARY','SUBSIDIARIES','STORAGE','LIFE\sES','PROFIT',
                 'TAX','VENTURE','DEVELOPMENT','LIMITED','BLDG','CONSTRUCTION', 'UNITED','LOAN','PORTFOLIO',
                 'WAREHOUSE','HO*ME*OWN[a-zA-Z]*','OWNERS','CONDO','TOWNHOME*', 'APARTM[ENTS]*']
private_word_noplural = ['BANK[ER]*']
private_abbrev = ['ASS','CO','CORP','INC','ORG','MNGT','MGMT','MTG','GRP',]
private_acro = ['LTD','LP','LLP','LLC','PLC','VC','RPBM','AA','HOA','LL','HMO','RAA']

#Convert all words into regex patterns
private_reglist = [pattern_word(w, plural=True) for w in private_words]+\
                  [pattern_abbrev(w) for w in private_abbrev]+\
                  [pattern_acronym(w) for w in private_acro]+\
                  [pattern_word(w, plural=False) for w in private_word_noplural]
#Create an overall pattern looking for any of these patterns
private_regunion = "(" + "|".join(private_reglist) + ")"

#OTHER INSTITUTIONS#
inst_words = ['CHURCH','DIOCESE','CATHEDRAL','BASILIC','TEMPLE','COUNTY','CTY','CITY','TOWN','MUNICIPAL','DISTRICT','SCHOOL','COLLEGE',
              'UNIVERSITY','INSTITUTE','ACADEMY','COLATION','UNITED\s?STATES','INTL','NATL','DEPT','ASSN','AMERICAN','BIBLE',
              'EDUCATIONAL','TRANSIT','HEALTH','CHRISTIAN','CATHOLIC','ADVENTIST','PROTESTANT','MUSLIM','ISLAM','BUDDHIST',
              'JEWISH','ORTHODOX','BAPTIST','FAMILY','NORTHWEST','COMMUNITY','AFFAIR','CLUB','LIBRARY','FOUNDATION',
              'FEDERAL','FEDERATION','SECRETARY','NATIONAL','ASSOCIATION','ASSO','ASSOCA','HOUSE','HOUSING','VACANT',
              'UNION','HOSPITAL', 'CENTER','CTR','RETIREMENT','CLUBHOUSE','SYSTEM','PUBLIC','RESTAURANTE*S*','MUSEUM',
              'COALITION','ASSISTED\sLIVING','UTILIT[A-Z]*','RESOURCE','HOME','FARM','FARMERS','LIVESTOCK','ASSOC',
              'POLICE','COUNCIL','OFFICE','IRRIGATION','BUREAU','DEPARTMENT','DPT','STATE','CHAPTER','MARKET','TRIBE',
              'SOCIETY','ALLIANCE','AUTHORITY','CLINIC','GOVERNMENT','GOVT','COMMITTEE','LOCAL','ACADEMY','ASSEMBLY',
              'AGENCY','GOD','MISSION','OF', 'FOR', 'IN', 'THE']
inst_reglist = [pattern_word(w, plural=True) for w in inst_words]+\
              [pattern_abbrev('ASSOC')]+\
              [pattern_acronym(w) for w in ['PAC','USA','HLTH']]
inst_regunion = "(" + "|".join(inst_reglist) + ")"

#TRUST#
trust_words = ['TTEE','TTE','TR','REV\s?TR','TRT','TST','TRST','TRSE','TRSTE','TRTEE','TRSES','TRTEES','TRSTEE','TSTEE',
               'TRUSTEE','TRUST','TRU','TRUSTE','TRUSTESS','GRANTEES',"DON[']T\sMAIL", 'UNKNOWN','[a-bA-B]*REVOCAB*L*E*']
trust_reglist = [pattern_word(w, plural=True) for w in trust_words]
trust_regunion = "(" + "|".join(trust_reglist) + ")"

#Filter out all non individuals
nonindiv_filter = re.compile("|".join([private_regunion,inst_regunion,trust_regunion])+'|[0-9]+', re.IGNORECASE) #also remove any party name containing numbers
arcpy.AddField_management(resid_nonull, 'OwnerTypeMM', field_type='text')
with arcpy.da.UpdateCursor(resid_nonull, ['Name','OwnerTypeMM']) as cursor:
    for row in cursor:
        if nonindiv_filter.search(row[0]) is not None:
            row[1] = 'non_individual'
        else:
            row[1] = 'individual'
        cursor.updateRow(row)
arcpy.MakeTableView_management(resid_nonull, 'residential_nonull_lyr', where_clause="OwnerTypeMM='individual'")
arcpy.CopyRows_management('residential_nonull_lyr', resid_indiv)
arcpy.MakeTableView_management(resid_nonull, 'residential_nonull_lyr', where_clause="OwnerTypeMM='non_individual'")
arcpy.CopyRows_management('residential_nonull_lyr', 'parcel_taxrollname_residnonindiv')

print('Processing: done removing non-indivIiduals, now parse names')
#Make copy of owner names to edit for parsing
arcpy.AddField_management(resid_indiv, field_name='Name_copy', field_type='text')
arcpy.CalculateField_management(resid_indiv, 'Name_copy',"!Name!","PYTHON")

# Split owner name into different parties (owners)
# First heck whether the string has &,/,\, or OR, AND, VS, +
# if so, split it at each of these characters
maxsplit = 10
owner_split = re.compile(r'[&]|\/|\\|\s{2,}|[+]|\bOR\b|\bAND\b|\bVS\b', re.IGNORECASE)
mainkey = 'party'
regex_field_split(fc=resid_indiv, splitfield='Name_copy',regx=owner_split, maxsplit=10, field_keyword=mainkey)

#Extract hereditary suffixes, write it to separate field and delete from subparty names
regx_suffix = re.compile(r'\bJR\b|\bSR\b|\bII\b|\bIII\b', re.IGNORECASE) #Regex to match hereditary suffixes
targetfield = re.compile(r'^{0}\d+$'.format(mainkey))
regex_field_extract(resid_indiv, targetfield, 'suffix', regx_suffix)

#Extract non-name keywords
nonname_extra = ['ET\s?AL','ET\s?UX?','H[/]?W','JTW?ROS','[&]\s?SONS','TIC','ET\s?VIR','AKA','PER REP']
nonname_extra_str = '|'.join([pattern_word(w, plural=False) for w in nonname_extra])
regx_extra = re.compile(nonname_extra_str, re.IGNORECASE)
targetfield = re.compile(r'^{0}\d+$'.format(mainkey))
regex_field_extract(resid_indiv, targetfield, 'extra', regx_extra)

#Extract content in or directly adjacent to parenthesis or quotes
#Do not include ' in the one-sided match to avoid O'MAHA D'ANGELO getting picked up
nickname_str = r'\(.+\)|' \
               r'\([^\s]+\s|' \
               r'\([^\s]+$|' \
               r'^[^\s]+\)|' \
               r'\s[^\s]+\)' \
    \
               r'\".+\"|' \
               r'\"[^\s]+\s|' \
               r'\"[^\s]+$|' \
               r'^[^\s]+\"|' \
               r'\s[^\s]+\"|' \
    \
               r"\'.+\'"
regx_nickname = re.compile(nickname_str, re.IGNORECASE | re.VERBOSE)
targetfield = re.compile(r'^{0}\d+$'.format(mainkey))
regex_field_extract(resid_indiv, targetfield, 'nick', regx_nickname)

#Delete special characters aside from ', -, commas, and spaces (to not exclude O'NEALS and L'AMARCA or compound names)
specialchar_str = r'[^\sa-zA-Z0-9\'-,]'
regx_specialchar= re.compile(specialchar_str, re.IGNORECASE)
targetfield = re.compile(r'^{0}\d+$'.format(mainkey))
regex_delete(resid_indiv, targetfield, regx_specialchar)

#Delete all leading or trailing special characters, including commas, hyphens, apostrophes (e.g. no need for comma if last character)
leadtrail_specialchar_str = r'(^[^\sa-zA-Z0-9])|([^\sa-zA-Z0-9]$)'
regx_leadtrail_specialchar= re.compile(leadtrail_specialchar_str, re.IGNORECASE)
targetfield = re.compile(r'^{0}\d+$'.format(mainkey))
regex_delete(resid_indiv, targetfield, regx_leadtrail_specialchar)

#Extract honorary prefixes
prefix_list = ['MC', 'MAC', 'VAN', 'DER', 'VON', 'VAN\s?DER', 'DU', 'DO', 'DA', 'DEL', 'DE', 'DU','DOS','DEN','ST',
                   'LA','SAN', 'AL', 'EL','DI','TEN', 'ZUM', 'ZU', 'NA', 'AF']
prefix_str = '|'.join([pattern_word(w, plural=False) for w in prefix_list])
regx_prefix= re.compile(prefix_str, re.IGNORECASE) #Regex to match honorary prefixes
regex_field_extract(resid_indiv, targetfield, 'prefix', regx_prefix, minwords=3)

#------------------------------------------------------------------------------------------------------
# PARSE NAMES
#------------------------------------------------------------------------------------------------------
#Join parcel attributes to get data provider ID
arcpy.JoinField_management(resid_indiv, 'PolyID', parcel, join_field='PolyID',
                           fields=['DataProviderType','DataProviderID'])

#Create a flag field for odd names that do not fit set patterns
arcpy.AddField_management(resid_indiv, 'flag', field_type='short')
arcpy.CalculateField_management(resid_indiv, 'flag',expression=0, expression_type='Python')

#Counties that organize owner names mostly by: last name, first name, middle name (or initial) - regardless of punctuation
lastfirst = ['{} County'.format(name) for name in
             ['Adams','Asotin','Benton','Chelan','Clark','Columbia', 'Douglas', 'Ferry', 'Franklin', 'Garfield',
              'Grant','Grays Harbor', 'Island', 'King', 'Kitsap','Kittitas', 'Klickitat', 'Lincoln','Okanogan', 'Pacific',
              'Pierce','Skagit', 'Skamania','Snohomish', 'Spokane', 'Thurston', 'Walla Walla']]
#Counties that organize owner names mostly by: first name, middle name (or initial), last name - regardless of punctuation
firstlast = ['{} County'.format(name) for name in
             ['Mason','Clallam', 'Pend Oreille','Wahkiakum', 'Whatcom', 'Whitman', 'Yakima']]

#Set up patterns
space_regx = re.compile(r'\s+') #Matches 1+ spaces for splitting
fullword_regx = re.compile(r"\b[A-Z]+[']?[-]?[A-Z]+\b", re.IGNORECASE) #Matches all non-single letter words

#Add party1 last names
arcpy.AddField_management(resid_indiv, 'party1_last1', field_type='text')
arcpy.AddField_management(resid_indiv, 'party1_last2', field_type='text')
arcpy.AddField_management(resid_indiv, 'party1_last3', field_type='text')

with arcpy.da.UpdateCursor(resid_indiv, ['party1','DataProviderID','party1_last1','party1_last2','party1_last3',
                                         'flag','party2']) as cursor:
    for row in cursor:
        print(row[0])
        wordlist = fullword_regx.findall(row[0])
        wordlen = len(wordlist)
        try:
            if wordlen > 4: #Flag name if more than 4 words
                row[5]=row[5]+1
            ######### #If county orders last name then first name
            if providerID[row[1]] in lastfirst:
                if wordlen==1 : #If only one full word
                    row[2] = wordlist[0] #Assign word to last name
                if wordlen>1 : #If more than one full word
                    try: #Flag if failed
                        if ',' in row[0]: #
                            lastns = [w.strip() for w in row[0].split(',')][0] #Get all words before comma
                            lastns_split = space_regx.split(lastns,3) #Split by space
                            lastns_split = [w for w in lastns_split if len(w)>1]   #Only keep full words
                            for i in range(0, min([3, len(lastns_split)])): #Assign each word to a different last name field
                                if lastns_split[i] not in lastns_split[0:i]: #Make sure not a repeat last name
                                    row[2+i]=lastns_split[i]
                        else:
                            if wordlen>2 and providerID[row[1]] == 'Kitsap County':
                                row[2]=wordlist[0] #Assign each of the first two words to a different last name field
                                row[3]=wordlist[1]
                            else:
                                row[2]=wordlist[0] #Assign first word as last name
                    except:
                        row[5] = row[5] + 1
            ######### #If county orders first then last name
            elif providerID[row[1]] in firstlast:
                try:  # Flag if failed
                    if wordlen>1: #If more than one full word (otherwise it's only a first name)
                        row[2]=wordlist[-1] #Last word is last name
                    if wordlen==1: #If only first name
                        if row[6] is not None:
                            row[2]= fullword_regx.findall(row[6])[-1] #Last word of second party
                        else:
                            row[2] = wordlist[0]
                except:
                    row[5] = row[5] + 1
            ######### #If not in counties list
            else:
                print('Not a county'+str(providerID[row[1]]))
        except:
            e = sys.exc_info()[1]
            print(e.args[0])
        cursor.updateRow(row)


#Add party1 first name
arcpy.AddField_management(resid_indiv, 'party1_first1', field_type='text')
with arcpy.da.UpdateCursor(resid_indiv, ['party1','DataProviderID','party1_first1','flag']) as cursor:
    for row in cursor:  # For each row
        print(row[0])
        wordlist = fullword_regx.findall(row[0])
        wordlen = len(wordlist)
        try:
            ######### #If county orders last name then first name
            if providerID[row[1]] in lastfirst:
                if wordlen > 1:  # If more than one full word
                    try:  # Flag if failed
                        if ',' in row[0]:  #
                            firstns = [w.strip() for w in row[0].split(',')][1]  # Get all words after comma
                            firstns_split = space_regx.split(firstns, 3)  # Split by space
                            firstns_split = [w for w in firstns_split if len(w) > 1]  # Only keep full words
                            row[2] = firstns_split[0] #Keep first full word
                        else:
                            if wordlen > 2 and providerID[row[1]] == 'Kitsap County':
                                row[2] = wordlist[2]  # Assign third word to first name
                            else:
                                row[2] = wordlist[1]  # Assign second word as first name
                    except:
                        row[3] = row[3] + 1
            ######### #If county orders first then last name
            elif providerID[row[1]] in firstlast:
                try:  # Flag if failed
                    row[2] = wordlist[0]  # first word is first name
                except:
                    row[3] = row[3] + 1
            ######### #If not in counties list
            else:
                print('Not a county' + str(providerID[row[1]]))
        except:
            e = sys.exc_info()[1]
            print(e.args[0])
        cursor.updateRow(row)

#Get first name for 98% of land owners

#------------------------------------------------------------------------------------------------------
# CLEAN UP NAMES
#------------------------------------------------------------------------------------------------------
#Check flags manually - nothing to correct
#Export to csv
arcpy.CopyRows_management(resid_indiv, os.path.join(resdir,'parcel_taxrollname_residindiv.csv'))

############################## TO DO IN THE FUTURE: MORE TWEAKS FOR NAME PARSING ######################################
#Get last name of second party
#Get first name of second party

#Extract titles? (extremely rare)
# prof_list = ['MR','MRS','MS','MD','DR','PHD']
# prof_str = '|'.join([pattern_word(w, plural=False) for w in prof_list])
# regx_prof= re.compile(prof_str, re.IGNORECASE) #Regex to match honorary prefixes
# regex_field_extract(resid_indiv, targetfield, 'prof', regx_prof, minwords=3)

#compound_names = ['LYNN', 'LYNNE', 'ANN', 'ANNE', 'JEAN', 'JO', 'MARIE', 'MARIA']

#Ignore repetitions within parties 'FLAMENCO ANGELA FLAMENCO ANGELA'
#'space - space' preceded by a single letter means new person, not hyphenated name
#'space - space' with full words on both sides are wrongly hyphenated last names or first names
#If only one word in first subparty, and only one word in the second, then only one party's last and first name or vice versa depending on county
#Check if one of the names in party 2+ match a last name in party 1 or vice-versa depending on firstlast order
#When only a letter in a party past #1, assign it as a first name initial with the last name of the previous party number
#Flag single parties with more than 4 things - quite likely not a person e.g. 'Schoessler fam rev liv tr'
#Analyze address line 1 as well, getting rid of non-indivs, numbers, and UNKNOWN, C/O, %, ATTN