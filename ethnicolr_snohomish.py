#Intall python 3.5
#Add to list of interpreters in Pycharm https://www.jetbrains.com/help/pycharm-edu/adding-existing-virtual-environment.html
#Install ethnicolr in pycharm settings

import ethnicolr
import pandas as pd
import numpy as np
import os
import re
import itertools

rootdir = 'C:\Mathis\ICSL\\flood_vulnerability'
datadir = os.path.join(rootdir,'data\\')
resdir = os.path.join(rootdir,'results\\')

#----------------------------------
# Import data
#----------------------------------
#Sheet with just name, address, property ID
os.chdir(resdir)
adr = pd.read_csv(os.path.join(datadir,'snohomish\\2018 Assr Roll at 2017 Roll Close - Excel\\2018 Assr Roll at 2017 Roll Close_nameaddress.csv'),
                 low_memory=False)
adr.info()
taxpr = adr[adr['Role'] == 'TAXPR'] #Taxpayer info is often updated way before the owner's name: https://snohomishcountywa.gov/413/Owner-Taxpayer-Address-Changes
taxpr.shape

#Sheet with parcel information
ptyp = pd.read_csv(os.path.join(datadir,'snohomish\\2018 Assr Roll at 2017 Roll Close - Excel\\2018 Assr Roll at 2017 Roll Close_maindata.csv'))
pdat = taxpr.set_index('property_id').join(ptyp.set_index('PropId'), how='left')
pdat.count()

#----------------------------------
# Only keep parcels with housing
#----------------------------------
#Nursery, primary & secondary school 681
#Special training and schooling 683
#Religious activity 691
#Medical and other health services 651
#University, college 682
#Senior citizen exemption residual 110
#Correctional instituions 674
#Retirement home/orphanages 174
#Military vases and reservations 675
pdat['UseCode'].unique()
housing_codes = [111, 112, 118, 130, 122, 113, 123, 133, 135, 131, 121, 138, 134, 124, 114, 117,
                 153, 132, 150, 189,115, 188, 142, 143, 116, 119, 752, 154, 151, 152,
                 174, 175, 141, 136, 139, 137, 187, 156, 155, 144, 145] #List of UseCodes that correpsond to housing
code_query ='|'.join(str(cod) for cod in housing_codes) #Build query
pdatsub = pdat[pdat['UseCode'].notnull()]
pdat_housing = pdatsub[pdatsub['UseCode'].str.contains(code_query)]


pdat_housing.to_csv('pdat_housing.csv')

#------------------------------------------------------------------------------------------------------
# PARSE NAMES
#------------------------------------------------------------------------------------------------------
# For good guide on regex: https://docs.python.org/3/howto/regex.html

#----------------------------------------------------------------
#Only keep individual owners rather than companies or institutions
#If doesn't work, try: https://github.com/datamade/probablepeople
#For now, use a lot of suffixes used in training probable people

#Functions to create regex patterns out of different word types: single words, abbrevations, and acronyms
def pattern_word(word, plural):
    if isinstance(word, str):
        rword = re.escape(word)
        if plural is True:
            reg_word = r'\b(' + rword + r')S?\b'
        else:
            reg_word = r'\b(' + rword + r')\b'
        return reg_word
    else:
        raise Warning('input is not a string')
def pattern_abbrev(word):
    if isinstance(word, str):
        rword = re.escape(word)
        reg_word = r'\b(' + word + r')\b[.]?'
        return reg_word
    else:
        raise Warning('input is not a string')
def pattern_acronym(word):
    if isinstance(word, str):
        rword = re.escape(word)
        reg_word = r'\s'+r'\W?'.join([i for i in word])+'([.]?[*]?\s*|\/)'
        return reg_word
    else:
        raise Warning('input is not a string')

#COMPANIES#
#Assign company names to word categories to be converted to regex pattern
private_words = ['ENTERPRISE','SHARE','COMPANY','PARTNER', 'PARTNERSHIP','PRTNRSHP','CORPORATION','MORTGAGE','INVEST[A-Z]*','ASSOCIATE',
         'BROKERAGE','COMPANY','CONSULTING','CONSULTANT','REALTY','ORGANIZATION','GROUP','SERVICE','PROPERTIY','APT',
         'APARTMENT','CONDOMINIUM','PROPERTIES','ESTATE','RANCH','HOLDING','CAPITAL','FUND','SUBSIDIARY','SUBSIDIARIES',
                 'LIMITED','ATTN','BLDG','CONSTRUCTION']
private_word_noplural = ['BANK']
private_abbrev = ['ASS','CO','CORP','INC','ORG']
private_acro = ['LTD','LP','LLP','LLC']

#Convert all words into regex patterns
private_reglist = [pattern_word(w, plural=True) for w in private_words]+\
                  [pattern_abbrev(w) for w in private_abbrev]+\
                  [pattern_acronym(w) for w in private_acro]+\
                  [pattern_word(w, plural=False) for w in private_word_noplural]
#Create an overall pattern looking for any of these patterns
private_regunion = "(" + ")|(".join(private_reglist) + ")"

#OTHER INSTITUTIONS#
inst_words = ['USA','CHURCH','DIOCESE','COUNTY','CTY','CITY','TOWN','MUNICIPAL','DISTRICT','SCHOOL','COLLEGE','UNIVERSITY','INSTITUTE',
              'LIBRARY','FOUNDATION', 'FEDERAL','SECRETARY','NATIONAL','ASSOCIATION','HOUSE','VACANT','UNION','HOSPITAL',
              'CENTER','CTR','RETIREMENT','UTILIT[A-Z]*','RESOURCE','HOME','FARM','ASSOC','POLICE','COUNCIL','OFFICE',
              'BUREAU','DEPARTMENT','DPT','STATE','CHAPTER','MARKET','TRIBE','SOCIETY','ALLIANCE','AUTHORITY','CLINIC',
              'GOVERNMENT','GOVT','COMMITTEE','LOCAL','ACADEMY','ASSEMBLY','AGENCY','GOD','MISSION','OF'] #add owners, homeowners
inst_reglist = [pattern_word(w, plural=True) for w in inst_words]+\
              [pattern_abbrev('ASSOC')]+\
              [pattern_acronym('PAC')]
inst_regunion = "(" + ")|(".join(inst_reglist) + ")"


#TRUST#
trust_words = ['TTEE','TTE','TRST','TRUSTEE', 'TRUST','GRANTEES']
trust_reglist = [pattern_word(w, plural=True) for w in trust_words]
trust_regunion = "(" + ")|(".join(trust_reglist) + ")"

#Filter parcel records
pdat_housingsub = pdat_housing[pdat_housing['PartyName'].notnull()]
pdat_housing.shape
#Check filtering
pdat_housing_private = pdat_housingsub[pdat_housingsub['PartyName'].str.contains(private_regunion, regex=True, case=False)]
pdat_housing_inst = pdat_housingsub[pdat_housingsub['PartyName'].str.contains(inst_regunion, regex=True, case=False)]
pdat_housing_trust = pdat_housingsub[pdat_housingsub['PartyName'].str.contains(trust_regunion, regex=True, case=False)]
pdat_housing_private.to_csv('pdat_housing_private.csv')
pdat_housing_inst.to_csv('pdat_housing_inst.csv')
pdat_housing_trust.to_csv('pdat_housing_trust.csv')

#Filter out all non individuals
nonindiv_filter = "|".join([private_regunion,inst_regunion,trust_regunion, ])+'|[0-9]+' #also remove any party name containing numbers
pdat_housingindiv = pdat_housingsub[~pdat_housingsub['PartyName'].str.contains(nonindiv_filter, regex=True, case=False)]
pdat_housingindiv.shape

#To do: assess percentage of people in census removed due to keywords (e.g. town, church, etc. as last names)

#Then check whether the string has &,/, or OR, if so, split it at each of these characters
splitparty = pdat_housingindiv['PartyName'].str.split(r'[&]|\/|\\|\s{2,}|\bOR\b|\bAND\b|\bJR\b|\bSR\b|\bVS\b|\bII\b|\bIII\b', expand=True)
newcols = ['party{}'.format(i) for i in list(range(1,splitparty.shape[1]+1))]
pdat_housingindiv[newcols] = splitparty
pdat_housingindiv.to_csv('pdat_housingindiv_checksplit.csv')

#Divide first name by space or comma
splitsubparty = pdat_housingindiv['party1'].str.split(r'\s(?!$)|[,]\s?|\s\bAKA\b\s', expand=True)
newcols = ['subparty1_{}'.format(i) for i in list(range(1,splitsubparty.shape[1]+1))]
pdat_housingindiv[newcols] = splitsubparty
pdat_housingindiv.to_csv('pdat_housingindivparty1_checksplit.csv')

#Subparty1, first column
#Find single letter, delete content and push all subsequent columns left until first full word
pdat_housingindiv['subparty1_{}'.format(splitsubparty.shape[1]+1)] = np.nan


mask = pdat_housingindiv.subparty1_1.str.len() == 1 | pdat_housingindiv.subparty1_1.isnull()
while pdat_housingindiv.loc[mask, newcols].shape[0] > 0:
    pdat_housingindiv.loc[mask, newcols] = \
        pdat_housingindiv.loc[mask, newcols].astype(str).shift(-1, axis=1)
pdat_housingindiv[pdat_housingindiv[newcols].isnull().all(axis=1)]





pdat_housingindiv.to_csv('pdat_housingindivparty1_checkreplace.csv')
pdat_housingindiv.loc[pdat_housingindiv['subparty1_1'].isnull()]


#Delete content if special character or space
filt=r'^\s$|^\s?\W\s?$|^$'
filt='LA'
pdat_housingindiv.loc[pdat_housingindiv['subparty1_1'].isnull(), newcols]


                          .str.contains(filt, regex=True), 'subparty1_1']


#Check if one of the names in parties 2+ match a last name in party 1
#ANN often leads to 2 first full word first names (e.g. Julie Ann)
#When three full words or more, assume that the first two are last names, and the others first names
#Keep names separated by special character (-, ')
#Split doesn't seem to be removing starting or trailing spaces, to do later after more splits
#When only a letter in a party past #1, assign it as a first name initial with the last name of the previous party number
#When first party only has one full word (last name) and then single letters (first and middle name e.g.), then full words for next parties are last names
#if party name only contains spaces, and following party is filled, then shift following party
#Create list of name suffixes and include the next word? Van, Al (when three full words or more Al adhad mohammed)
#Ignore 'et al'
#Ignore repetitions within parties 'FLAMENCO ANGELA FLAMENCO ANGELA'
#'space - space' preceded by a single letter means new person, not hyphenated name
#'space - space' with full words on both sides are wrongly hyphenated last names or first names
#Ignore what is in parenthesis (often americanized name for foreign immigrants)
#If only one word in first subparty, and only one word in the second, then only one party last and first name

#VAN, VON, VANDER, Van der, du, do, DA, der, DEL, DE, ST,LA,SAN,AL,DI, DOS,O,Den, Ten, Zum, na, zu, af,



#Count number of words (including hyphenated ones):
#1: Last name
#2: Last name, First name
#3: Last name, first name, middle name
#>4: Last name, first name, middle name, suffix or additional name - flag




p=re.compile(pattern_acronym('llc'), re.IGNORECASE)
#p=re.compile(r'\/')
p.search('DIMENSION TOWNHOUSES Llc')







#Watch out for
#- hyphenated last names
#  'JR', 'SR','I', 'II','III', 'VAN', 'DE',
#OR between first names as a separator like & and /

#VACANT SPACE should be classified as not housing

#Format
#Last name, first name (or initial), middle name (or initial) (& or /) (last name), first name, middle name (or initial)
#If one word before and after / or & just last name
#If only one word after & or /: first name
#If only one work + one initial after & or /: then first name, middle name
#If two full words after & or /: last name, first name


