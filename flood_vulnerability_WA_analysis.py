import os
import sys
import collections
import arcpy
import geopandas as gpd
import pandas as pd
import re

#Folder structure
rootdir = 'C:/Mathis/ICSL/flood_vulnerability'
datadir = os.path.join(rootdir, 'data')
resdir = os.path.join(rootdir, 'results')
gdb_vulne = os.path.join(resdir,'flood_vulnerability.gdb')
gdb = os.path.join(resdir,'flood_risk.gdb')
arcpy.env.workspace = gdb

#Input data variables
blockproj = 'block2010_proj'
tracts_proj = 'tracts_WAproj'
USadmin = 'C:\Mathis\ICSL\stormwater\data\USA_adm_gdb\USA_adm.gdb'
USstates = os.path.join(USadmin, 'USA_adm1')
counties = os.path.join(datadir,"WA_County_Boundaries\WA_County_Boundaries.shp")
parcels_flood_attri = 'parcel_blocks_fill_flood_attri'
tracts_proj = 'tracts_WAproj'
tract_blockflood = 'tract_blockfloodcomp_tab'

#Output variables:
tract_raceflood = os.path.join(gdb, 'tract_raceflood')
#----------------------------------- PARCEL-BASED ANALYSIS -------------------------------------------------------------
try:
    arcpy.AddField_management(parcels_flood_attri, 'floodpop', 'FLOAT')
    arcpy.AddField_management(parcels_flood_attri, 'FEMApop', 'FLOAT')
except Exception:
    e = sys.exc_info()[1]
    print(e.args[0])

#Create columns to hold total population for each race
allcols = [f.name for f in arcpy.ListFields(parcels_flood_attri)]
regx_racecols = re.compile("(api|aian|asi|black|white|hisp|oth|wf$|.*wln$|race)(?!.*pop)")
racecols = [f for f in allcols if regx_racecols.search(f)] #Race probability columns for all races and models

racecols_pop = []
for c in racecols:
    racecols_pop.extend((c + '_pop', c + '_popflood', c + '_popFEMA'))
for c in racecols_pop:
    if c not in allcols:
        print('--- Add {} field'.format(c))
        arcpy.AddField_management(parcels_flood_attri, c, 'FLOAT')
    else:
        print('{} field already in feature class'.format(c))

recnum = float(arcpy.GetCount_management(parcels_flood_attri).getOutput(0))

#Compute total population and population living within flood zone for each race for each parcel
#checkcols = ['PARCELPOP','FloodStatus','FEMAFloodStatus','floodpop','FEMApop'] + racecols + racecols_pop
with arcpy.da.UpdateCursor(parcels_flood_attri, ['PARCELPOP','FloodStatus','FEMAFloodStatus','floodpop','FEMApop',
                                                 'surname', 'censuspop','lastpop','lastfirstpop'] +
                                                racecols + racecols_pop) as cursor:
    x = 0
    for row in cursor:
        if (x % 1000) == 0:
            print(100*x/recnum)
        if row[0] > 0:
            row[3] = row[0] * row[1] #Compute parcel population within flood zone (fathom data)
            row[4] = row[0] * row[2] #`` (FEMA data)
            #print('PARCELPOP: {0}, floodpop: {1}, FEMApop: {2}'.format(row[0],row[3], row[4]))

            #For each race probability column, compute population in parcel
            for i in range(0, len(racecols)):
                if row[i + 9] is not None: #If data about race probability distribution
                    # print('Compute population in the parcel of that race {0} = {1}*{2}'.format(\
                    # checkcols[(i * 3) + len(racecols) + 5], checkcols[i+5], checkcols[0]))
                    row[(i * 3) + len(racecols) + 9] = row[i + 9] * row[0] #Compute the population in the parcel of that race
                    row[(i * 3) + len(racecols) + 10] = row[i + 9] * row[3] #Compute the population of that race living within flood zone (fathom data)
                    row[(i * 3) + len(racecols) + 11] = row[i + 9] * row[4] #Compute the population of that race living within flood zone (FEMA data)
        cursor.updateRow(row)
        x += 1

#Dissolve/aggregate
for f in arcpy.ListFields(parcels_flood_attri):
    print(f.name)
sumcols_p = ['TaxRollIDC', 'HOUSINGADJ', 'PARCELPOP','TAXROLLNUM', 'BuildNum', 'BuildFld','BuildFEMAFld',
           'FloodStatus', 'floodpop', 'FEMAFloodStatus', 'FEMApop','Shape_Area'] + racecols_pop
stat_p = []
for c in sumcols_p:
    stat_p.append([c, 'SUM'])
#arcpy.Dissolve_management(parcels_flood_attri, tract_raceflood, dissolve_field='GEOID10_t', statistics_fields = statf)
arcpy.MakeFeatureLayer_management(parcels_flood_attri, 'parcelsflood_lyr', 'NOT "GEOID10_t" IS NULL')
arcpy.Statistics_analysis('parcelsflood_lyr', tract_raceflood+'_tab', statistics_fields=stat_p, case_field='GEOID10_t')

#----------------------------------- CENSUS BLOCK-BASED ANALYSIS -------------------------------------------------------------
arcpy.AddField_management('blockurbanflood_diss', 'GEOID10_t', field_type='TEXT')
arcpy.CalculateField_management('blockurbanflood_diss', 'GEOID10_t', expression = '!BLOCKID10![0:11]', expression_type='PYTHON')
arcpy.AlterField_management('blockurbanflood_diss', 'SUM_URBANFLOODAREA', 'URBANFLOODAREA', 'URBANFLOODAREA')
arcpy.AlterField_management('blockurbanflood_diss', 'SUM_FLOODAREA', 'FLOODAREA', 'FLOODAREA')

#Compute population living within flood zone for each census block
arcpy.AddGeometryAttributes_management('blockurbanflood_diss', 'AREA_GEODESIC', Area_Unit="SQUARE_METERS")
arcpy.JoinField_management('blockurbanflood_diss', 'BLOCKID10', blockproj, 'BLOCKID10', 'POP10')
arcpy.AddField_management('blockurbanflood_diss', 'FLOODPOP_B', field_type='FLOAT')
arcpy.AddField_management('blockurbanflood_diss', 'FEMAPOP_B', field_type='FLOAT')

with arcpy.da.UpdateCursor('blockurbanflood_diss', ['POP10', 'FLOODPOP_B', 'FEMAPOP_B', 'FLOODAREA', 'FEMAFLOODAREA', 'AREA_GEO', #0, 1, 2, 3, 4, 5
                                                    'URBANFLOODAREA', 'URBANFEMAFLOODAREA', 'URBANAREA']) as cursor: #6, 7, 8
    for row in cursor:
        if row[8] > 0:
            row[1] = row[0]*row[6]/row[8]
            row[2] = row[0]*row[7]/row[8]
        elif row[5] > 0:
            row[1] = row[0]*row[3]/row[5]
            row[2] = row[0]*row[4]/row[5]
        cursor.updateRow(row)

#Aggregate at census tract level
for f in arcpy.ListFields('blockurbanflood_diss'):
    print(f.name)
sumcols_t = ['URBANAREA', 'FLOODAREA', 'URBANFLOODAREA', 'FEMAFLOODAREA', 'URBANFEMAFLOODAREA', 'POP10', 'FLOODPOP_B', 'FEMAPOP_B']
stat_t = []
for c in sumcols_t:
    stat_t.append([c, 'SUM'])
arcpy.Statistics_analysis('blockurbanflood_diss', tract_blockflood, statistics_fields=stat_t, case_field='GEOID10_t')

################################################### JOIN TRACT LEVEL DATA ##############################################
arcpy.MakeFeatureLayer_management(tracts_proj, 'tractslyr')
arcpy.AddJoin_management('tractslyr', 'GEOID10', tract_blockflood, 'GEOID10_t')
arcpy.AddJoin_management('tractslyr', 'GEOID10', tract_raceflood, 'GEOID10_t')
arcpy.CopyFeatures_management('tractslyr', 'tracts_floodfinal')
arcpy.AddGeometryAttributes_management('tracts_floodfinal', 'AREA_GEODESIC', 'SQUARE_METERS')

###################################################### NOT TESTED, STILL TO BE WRITTEN #################################
# Compute percentage of population
['urbanper', 'blockfloodper', 'blockFEMAper', 'parcelfloodper', 'parcelFEMAper']
racecols_popsum = ['SUM_'+c for c in racecols_pop]
racecols_per = []
for c in racecols:
    racecols_per.extend((c + '_per', c + '_floodper', c + '_FEMAper', c + '_floodratio', c + '_FEMAratio'))
#Run through AddField loop


#Compute percentage flooded population for all models, race, and ratios
with arcpy.da.UpdateCursor(parcels_flood_attri, ['AREA_GEO', 'SUM_URBANAREA', 'SUM_POP10', 'SUM_FLOODPOP_B', 'SUM_FEMAPOP_B'] + #0, 1, 2, 3, 4
                                                ['urbanper', 'blockfloodper', 'blockFEMAper'] + #5, 6, 7
                                                ['SUM_PARCELPOP','SUM_floodpop','SUM_FEMApop', 'parcelfloodper', 'parcelFEMAper'] + #8, 9, 10, 11, 12
                                                racecols_popsum + racecols_per) as cursor: #13, ... -
    x = 0
    for row in cursor:
        if (x % 1000) == 0:
            print(100*x/recnum)

        #Compute total percentage population flooded
        if row[0] > 0:
            row[5] = row[1]/row[0]  # urbanper = SUM_URBANAREA/AREA_GEO
        if row[2] > 0:
            row[6] = row[3]/row[2]  # blockfloodper = SUM_FLOODPOP_B/SUM_POP10
            row[7] = row[4]/row[2]  # blockFEMAper = SUM_FEMAPOP_B/SUM
        if row[8] > 0:
            row[11] = row[9]/row[8]  # parcelfloodper = SUM_floodpop/SUM_PARCELPOP
            row[12] = row[10]/row[8]  # parcelFEMAper = SUM_FEMApop/SUM_PARCELPOP

        #Compute percentage flooded population that and flooded to non-flooded race-based ratio
        for i in range(0, len(racecols)):
            if row[i + 13] is not None:  # If data about race probability distribution
                # print('Compute population in the parcel of that race {0} = {1}*{2}'.format(\
                # checkcols[(i * 3) + len(racecols) + 5], checkcols[i+5], checkcols[0]))

                row[(i * 5) + len(racecols_popsum) + 13] = row[(i * 3) + 13]/row[(i * 3) + 13]  # % of population of given race
                row[(i * 5) + len(racecols_popsum) + 14] = row[(i * 3) + 15]/row[(i * 3) + 13]  # % of fathom flooded pop that is of given race
                row[(i * 5) + len(racecols_popsum) + 15] = (row[(i * 3) + 14]/row[(i * 3) + 13])  # % of FEMA flooded pop that is of given race
                row[(i * 5) + len(racecols_popsum) + 16] =  # Ratio of % fathom flooded pop/% total pop that is of given race
                # Ratio of % FEMA flooded pop/% total pop that is of given race

        cursor.updateRow(row)
        x += 1

_pop, _floodpop, _FEMApop
#TO DO IN SUMMARY
# - try excluding apartment buildings
# - exclude government lodging