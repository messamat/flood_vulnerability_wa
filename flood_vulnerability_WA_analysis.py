"""
Author: Mathis L. Messager
Affiliation: School of Environmental and Forest Sciences, University of Washington
Contact info: messamat@uw.edu
Date created: October 2019

Purpose: Compute flood risk at census tract level by aggregating parcel-level and census block-level information
"""

import os
import sys
import collections
import arcpy
import geopandas as gpd
import pandas as pd
import re

#Folder structure
rootdir = os.path.dirname(os.path.abspath(__file__)).split('\\src')[0]
datadir = os.path.join(rootdir, 'data')
resdir = os.path.join(rootdir, 'results')
gdb_vulne = os.path.join(resdir,'flood_vulnerability.gdb')
gdb = os.path.join(resdir,'flood_risk.gdb')
arcpy.env.workspace = gdb

#Input data variables
blockproj = 'block2010_proj'
tracts_proj = 'tracts_WAproj'
urbanareas = os.path.join(datadir, 'TIGER2017/tl_2010_us_uac10/tl_2010_us_uac10.shp')
USadmin = 'C:\Mathis\ICSL\stormwater\data\USA_adm_gdb\USA_adm.gdb'
USstates = os.path.join(USadmin, 'USA_adm1')
counties = os.path.join(datadir,"WA_County_Boundaries\WA_County_Boundaries.shp")
parcel_flood_attri = 'parcel_blocks_fill_flood_attri'
tracts_proj = 'tracts_WAproj'
tract_blockflood = 'tract_blockfloodcomp_tab'

#Output variables:
tract_raceflood = os.path.join(gdb, 'tract_raceflood')
tract_floodfinal = 'tracts_floodfinal'

arcpy.env.overwriteOutput = True
arcpy.env.qualifiedFieldNames = False

#Create column names to hold total population for each race
allcols = [f.name for f in arcpy.ListFields(parcel_flood_attri)]
regx_racecols = re.compile("(api|aian|asi|black|white|hisp|oth|wf$|.*wln$|race)(?!.*pop)")
racecols = [f for f in allcols if regx_racecols.search(f)] #Race probability columns for all races and models

racecols_pop = []
for c in racecols:
    racecols_pop.extend((c + '_pop', c + '_popflood', c + '_popFEMA'))

censuscols = [idx for idx, colname in enumerate(racecols) if re.compile('pct').search(colname)]  #Get number for cursor of census based race prediction columns
fullcols = [idx for idx, colname in enumerate(racecols) if re.compile('[a-z]fl$|_wf').search(colname)] #Get number for cursor of florida full name based race prediction

#----------------------------------- PARCEL-BASED ANALYSIS -------------------------------------------------------------
try:
    arcpy.AddField_management(parcel_flood_attri, 'floodpop', 'FLOAT')
    arcpy.AddField_management(parcel_flood_attri, 'FEMApop', 'FLOAT')
except Exception:
    e = sys.exc_info()[1]
    print(e.args[0])

for c in racecols_pop:
    if c not in allcols:
        print('--- Add {} field'.format(c))
        arcpy.AddField_management(parcel_flood_attri, c, 'FLOAT')
    else:
        print('{} field already in feature class'.format(c))

#Add fields to sum population with race predictions (to use as reference to compute ratios)
arcpy.AddField_management(parcel_flood_attri, 'census_pop', 'FLOAT')
arcpy.AddField_management(parcel_flood_attri, 'census_popflood', 'FLOAT')
arcpy.AddField_management(parcel_flood_attri, 'census_popfema', 'FLOAT')

arcpy.AddField_management(parcel_flood_attri, 'last_pop', 'FLOAT')
arcpy.AddField_management(parcel_flood_attri, 'last_popflood', 'FLOAT')
arcpy.AddField_management(parcel_flood_attri, 'last_popfema', 'FLOAT')

arcpy.AddField_management(parcel_flood_attri, 'lastfirst_pop', 'FLOAT')
arcpy.AddField_management(parcel_flood_attri, 'lastfirst_popflood', 'FLOAT')
arcpy.AddField_management(parcel_flood_attri, 'lastfirst_popfema', 'FLOAT')

recnum = float(arcpy.GetCount_management(parcel_flood_attri).getOutput(0))

#Compute total population and population living within flood zone for each race and model in each parcel
# checkcols = ['PARCELPOP','FloodStatus','FEMAFloodStatus','floodpop','FEMApop',
#                                                  'surname', 'census_pop', 'census_popflood', 'census_popfema',
#                                                  'last_pop', 'last_popflood', 'last_popfema',
#                                                  'lastfirst_pop', 'lastfirst_popflood', 'lastfirst_popfema'] + racecols + racecols_pop
with arcpy.da.UpdateCursor(parcel_flood_attri, ['PARCELPOP','FloodStatus','FEMAFloodStatus','floodpop','FEMApop', #0, 1 , 2, 3
                                                 'surname', 'census_pop', 'census_popflood', 'census_popfema',
                                                 'last_pop', 'last_popflood', 'last_popfema',
                                                 'lastfirst_pop', 'lastfirst_popflood', 'lastfirst_popfema'] +
                                                racecols + racecols_pop) as cursor:
    x = 0
    begind = 15
    for row in cursor:
        if (x % 1000) == 0:
            print(100*x/recnum)
        if row[0] > 0:
            row[3] = row[0] * row[1] #Compute parcel population within flood zone (fathom data)
            row[4] = row[0] * row[2] #`` (FEMA data)
            #print('PARCELPOP: {0}, floodpop: {1}, FEMApop: {2}'.format(row[0],row[3], row[4]))

            #Compute population with race/ethnicity predictions for each model type (census, last name, last and first name)
            row[6] = row[0] * any([row[c + begind] > 0 for c in censuscols]) #censuspop = PARCELPOP * 1 (if model predictions for full name - otherwise 0)
            row[7] = row[6] * row[1] #census_popflood = censuspop * FloodStatus
            row[8] = row[6] * row[2] #census_popfema = censuspop*FEMAFloodStatus

            row[9] = row[0] * (row[5] != '') #If there is a surname, then last name models have predictions
            row[10] = row[9] * row[1] #census_popflood = censuspop * FloodStatus
            row[11] = row[9] * row[2] #census_popfema = censuspop*FEMAFloodStatus

            row[12] = row[0] * any([row[c + begind] > 0 for c in fullcols]) #lastfirstpop = PARCELPOP * sum(full name predictions) (0 if not predicted, 1 if predicted)
            row[13] = row[12] * row[1] #lastfirstpop = PARCELPOP * sum(full name predictions) (0 if not predicted, 1 if predicted)
            row[14] = row[12] * row[2] #lastfirstpop = PARCELPOP * sum(full name predictions) (0 if not predicted, 1 if predicted)

            #For each race probability column, compute population in parcel
            for i in range(0, len(racecols)):
                if row[i + begind] is not None: #If data about race probability distribution
                    # print('Compute population in the parcel of that race {0} = {1}*{2}'.format(\
                    # checkcols[(i * 3) + len(racecols) + 5], checkcols[i+5], checkcols[0]))
                    #Different if statements allow to use different population as reference for ratio as not all population's race could be determined and varied by model
                    if i in censuscols:
                        row[(i * 3) + len(racecols) + begind] = row[i + begind] * row[6] #Compute the population in the parcel of that race
                        row[(i * 3) + len(racecols) + begind + 1] = row[i + begind] * row[7] #Compute the population of that race living within flood zone (fathom data)
                        row[(i * 3) + len(racecols) + begind + 2] = row[i + begind] * row[8] #Compute the population of that race living within flood zone (FEMA data)
                    elif i in fullcols:
                        row[(i * 3) + len(racecols) + begind] = row[i + begind] * row[12] #Compute the population in the parcel of that race
                        row[(i * 3) + len(racecols) + begind + 1] = row[i + begind] * row[13] #Compute the population of that race living within flood zone (fathom data)
                        row[(i * 3) + len(racecols) + begind + 2] = row[i + begind] * row[14] #Compute the population of that race living within flood zone (FEMA data)
                    else:
                        row[(i * 3) + len(racecols) + begind] = row[i + begind] * row[9] #Compute the population in the parcel of that race
                        row[(i * 3) + len(racecols) + begind + 1] = row[i + begind] * row[10] #Compute the population of that race living within flood zone (fathom data)
                        row[(i * 3) + len(racecols) + begind + 2] = row[i + begind] * row[11] #Compute the population of that race living within flood zone (FEMA data)
        cursor.updateRow(row)
        x += 1

#Aggregate parcel-level statistics at tract level for tract-level analysis
for f in arcpy.ListFields(parcel_flood_attri):
    print(f.name)
sumcols_p = ['TaxRollIDC', 'HOUSINGADJ', 'PARCELPOP','TAXROLLNUM', 'BuildNum', 'BuildFld','BuildFEMAFld',
             'FloodStatus', 'floodpop', 'FEMAFloodStatus', 'FEMApop', 'census_pop', 'census_popflood', 'census_popfema',
             'last_pop', 'last_popflood', 'last_popfema','lastfirst_pop', 'lastfirst_popflood','lastfirst_popfema',
             'Shape_Area'] + racecols_pop
stat_p = []
for c in sumcols_p:
    stat_p.append([c, 'SUM'])
#arcpy.Dissolve_management(parcel_flood_attri, tract_raceflood, dissolve_field='GEOID10_t', statistics_fields = statf)
arcpy.MakeFeatureLayer_management(parcel_flood_attri, 'parcelflood_lyr', 'NOT "GEOID10_t" IS NULL')
arcpy.Statistics_analysis('parcelflood_lyr', tract_raceflood+'_tab', statistics_fields=stat_p, case_field='GEOID10_t')

#----------------------------------- CENSUS BLOCK-BASED ANALYSIS -------------------------------------------------------------
arcpy.AddField_management('blockurbanflood_diss', 'GEOID10_t', field_type='TEXT')
arcpy.CalculateField_management('blockurbanflood_diss', 'GEOID10_t', expression = '!BLOCKID10![0:11]', expression_type='PYTHON')
arcpy.AlterField_management('blockurbanflood_diss', 'SUM_URBANFLOODAREA', 'URBANFLOODAREA', 'URBANFLOODAREA')
arcpy.AlterField_management('blockurbanflood_diss', 'SUM_FLOODAREA', 'FLOODAREA', 'FLOODAREA')

#Compute population living within flood zone for each census block
arcpy.AddGeometryAttributes_management('blockurbanflood_diss', 'AREA_GEODESIC', Area_Unit="SQUARE_METERS")
arcpy.JoinField_management('blockurbanflood_diss', 'BLOCKID10', blockproj, 'BLOCKID10', 'POP10')
arcpy.AddField_management('blockurbanflood_diss', 'FLOODPOP_B', field_type='FLOAT')
arcpy.AddField_management('blockurbanflood_diss', 'FEMAPOP_B', field_type='FLOAT')

with arcpy.da.UpdateCursor('blockurbanflood_diss', ['POP10', 'FLOODPOP_B', 'FEMAPOP_B', 'FLOODAREA', 'FEMAFLOODAREA', 'AREA_GEO', #0, 1, 2, 3, 4, 5
                                                    'URBANFLOODAREA', 'URBANFEMAFLOODAREA', 'URBANAREA']) as cursor: #6, 7, 8
    for row in cursor:
        if row[8] > 0:
            row[1] = row[0]*row[6]/row[8]
            row[2] = row[0]*row[7]/row[8]
        elif row[5] > 0:
            row[1] = row[0]*row[3]/row[5]
            row[2] = row[0]*row[4]/row[5]
        cursor.updateRow(row)

#Aggregate at census tract level
sumcols_t = ['URBANAREA', 'FLOODAREA', 'URBANFLOODAREA', 'FEMAFLOODAREA', 'URBANFEMAFLOODAREA', 'POP10', 'FLOODPOP_B', 'FEMAPOP_B']
stat_t = []
for c in sumcols_t:
    stat_t.append([c, 'SUM'])
arcpy.Statistics_analysis('blockurbanflood_diss', tract_blockflood, statistics_fields=stat_t, case_field='GEOID10_t')

############################################ COMPUTE TRACT-LEVEL STATISTICS ############################################
arcpy.MakeFeatureLayer_management(tracts_proj, 'tractslyr')
arcpy.AddJoin_management('tractslyr', 'GEOID10', tract_blockflood, 'GEOID10_t')
arcpy.AddJoin_management('tractslyr', 'GEOID10', tract_raceflood + '_tab', 'GEOID10_t')
arcpy.CopyFeatures_management('tractslyr', tract_floodfinal)
arcpy.AddGeometryAttributes_management(tract_floodfinal, 'AREA_GEODESIC', Area_Unit='SQUARE_METERS')

# Compute percentage of population
racecols_popsum = ['SUM_' + c for c in racecols_pop]
racecols_per = []
for c in racecols:
    racecols_per.extend((c + '_per', c + '_floodper', c + '_FEMAper', c + '_floodratio', c + '_FEMAratio'))

for c in ['urbanareaper', 'blockfloodper', 'blockFEMAper', 'parcelfloodper', 'parcelFEMAper'] + racecols_per:
    print(c)
    arcpy.AddField_management(tract_floodfinal, c, 'FLOAT')


tract_cursorcols = ['AREA_GEO', 'SUM_URBANAREA', 'SUM_POP10', 'SUM_FLOODPOP_B', 'SUM_FEMAPOP_B'] + \
                   ['urbanareaper', 'blockfloodper', 'blockFEMAper'] + \
                   ['SUM_PARCELPOP','SUM_floodpop','SUM_FEMApop', 'parcelfloodper', 'parcelFEMAper'] +  \
                   ['SUM_census_pop', 'SUM_census_popflood', 'SUM_census_popfema',
                    'SUM_lastfirst_pop', 'SUM_lastfirst_popflood','SUM_lastfirst_popfema',
                    'SUM_last_pop', 'SUM_last_popflood', 'SUM_last_popfema'] +\
                   racecols_popsum + racecols_per

#Compute percentage flooded population for all models, race, and ratios
with arcpy.da.UpdateCursor(tract_floodfinal, ['AREA_GEO', 'SUM_URBANAREA', 'SUM_POP10', 'SUM_FLOODPOP_B', 'SUM_FEMAPOP_B'] +
                                                ['urbanareaper', 'blockfloodper', 'blockFEMAper'] +  # 5, 6, 7
                                                ['SUM_PARCELPOP','SUM_floodpop','SUM_FEMApop', 'parcelfloodper', 'parcelFEMAper'] +  # 8, 9, 10, 11, 12
                                                ['SUM_census_pop', 'SUM_census_popflood', 'SUM_census_popfema',  # 13, 14, 15,
                                                 'SUM_lastfirst_pop', 'SUM_lastfirst_popflood','SUM_lastfirst_popfema',  # 16, 17, 18
                                                 'SUM_last_pop', 'SUM_last_popflood', 'SUM_last_popfema'] +  # 19, 20, 21
                                                racecols_popsum + racecols_per) as cursor: #22, ... -
    x =0
    begind = 22
    for row in cursor:
        print(x)

        # Compute total percentage population flooded
        if row[0] > 0:
            row[5] = row[1]/row[0]  # urbanper = SUM_URBANAREA/AREA_GEO
        if row[2] > 0:
            row[6] = row[3]/row[2]  # blockfloodper = SUM_FLOODPOP_B/SUM_POP10
            row[7] = row[4]/row[2]  # blockFEMAper = SUM_FEMAPOP_B/SUM_POP10
        if row[8] > 0:
            row[11] = row[9]/row[8]  # parcelfloodper = SUM_floodpop/SUM_PARCELPOP
            row[12] = row[10]/row[8]  # parcelFEMAper = SUM_FEMApop/SUM_PARCELPOP

        # Compute percentage flooded population and flooded to non-flooded race-based ratio
        # for each reach race, race prediction model, and flood model combination
        for i in range(0, len(racecols)):
            if row[i * 3 + begind] is not None:  # If data about race probability distribution
                # print('Compute population in the parcel of that race {0} = {1}*{2}'.format(\
                # checkcols[(i * 3) + len(racecols) + 5], checkcols[i+5], checkcols[0]))
                if i in censuscols and row[13] > 0:
                    # % of population of given race = population of that race/model population
                    row[(i * 5) + len(racecols_popsum) + begind] = row[(i * 3) + begind]/row[13]

                    if row[14] > 0: #fathom flooded pop > 0
                        # % of fathom flooded pop that is of given race = fathom flooded population of that race/model fathom flooded population
                        row[(i * 5) + len(racecols_popsum) + begind + 1] = row[(i * 3) + begind + 1]/row[14]
                        if row[(i * 3) + begind] > 0: #If population of that race is not 0
                            # Ratio of % fathom flooded pop/% total pop that is of given race
                            row[(i * 5) + len(racecols_popsum) + begind + 3] = (row[(i * 3) + begind + 1] / row[14]) / (row[(i * 3) + begind] / row[13])
                    if row[15] > 0: #FEMA flooded pop > 0
                        # % of FEMA flooded pop that is of given race =  FEMA flooded population of that race/model FEMA flooded population
                        row[(i * 5) + len(racecols_popsum) + begind + 2] = row[(i * 3) + begind + 2]/row[15]
                        if row[(i * 3) + begind] > 0:  # If population of that race is not 0
                            # Ratio of % FEMA flooded pop/% total pop that is of given race
                            row[(i * 5) + len(racecols_popsum) + begind + 4] = row[(i * 3) + begind + 2]/row[15]/(row[(i * 3) + begind]/row[13])

                elif i in fullcols and row[16] > 0:
                    # % of population of given race = population of that race/model population
                    row[(i * 5) + len(racecols_popsum) + begind] = row[(i * 3) + begind]/row[16]

                    if row[17] > 0:
                        # % of fathom flooded pop that is of given race = fathom flooded population of that race/model fathom flooded population
                        row[(i * 5) + len(racecols_popsum) + begind + 1] = row[(i * 3) + begind + 1]/row[17]
                        if row[(i * 3) + begind] > 0:  # If population of that race is not 0
                            # Ratio of % fathom flooded pop/% total pop that is of given race
                            row[(i * 5) + len(racecols_popsum) + begind + 3] = (row[(i * 3) + begind + 1]/row[17])/(row[(i * 3) + begind]/row[16])
                    if row[18] > 0:
                        # % of FEMA flooded pop that is of given race =  FEMA flooded population of that race/model FEMA flooded population
                        row[(i * 5) + len(racecols_popsum) + begind + 2] = row[(i * 3) + begind + 2]/row[18]
                        if row[(i * 3) + begind] > 0:  # If population of that race is not 0
                            # Ratio of % FEMA flooded pop/% total pop that is of given race
                            row[(i * 5) + len(racecols_popsum) + begind + 4] = row[(i * 3) + begind + 2]/row[18]/(row[(i * 3) + begind]/row[16])

                elif row[19] > 0:
                    # % of population of given race = population of that race/model population
                    row[(i * 5) + len(racecols_popsum) + begind] = row[(i * 3) + begind]/row[19]
                    if row[20] > 0:
                        # % of fathom flooded pop that is of given race = fathom flooded population of that race/model fathom flooded population
                        row[(i * 5) + len(racecols_popsum) + begind + 1] = row[(i * 3) + begind + 1]/row[20]
                        if row[(i * 3) + begind] > 0:  # If population of that race is not 0
                            # Ratio of % fathom flooded pop/% total pop that is of given race
                            row[(i * 5) + len(racecols_popsum) + begind + 3] = (row[(i * 3) + begind + 1]/row[20]) / (row[(i * 3) + begind]/row[19])
                    if row[21] > 0:
                        # % of FEMA flooded pop that is of given race =  FEMA flooded population of that race/model FEMA flooded population
                        row[(i * 5) + len(racecols_popsum) + begind + 2] = row[(i * 3) + begind + 2]/row[21]
                        if row[(i * 3) + begind] > 0:  # If population of that race is not 0
                            # Ratio of % FEMA flooded pop/% total pop that is of given race
                            row[(i * 5) + len(racecols_popsum) + begind + 4] = row[(i * 3) + begind + 2]/row[21]/(row[(i * 3) + begind]/row[19])
        cursor.updateRow(row)
        x += 1

#Compute proportion of units occupied by renters in census tracts.
arcpy.AddField_management(tract_floodfinal, 'rentalunits_perc', 'FLOAT')
arcpy.AddField_management(tract_floodfinal, 'lastpred_perc', 'FLOAT')
with arcpy.da.UpdateCursor(tract_floodfinal, ['rentalunits_perc', 'DP0210003', 'DP0210001',
                                              'lastpred_perc', 'SUM_last_pop', 'SUM_PARCELPOP']) as cursor:
    for row in cursor:
        if row[2] > 0:
            row[0] = row[1]/float(row[2])
        if row[5] > 0:
            row[3] = row[4]/row[5]
        cursor.updateRow(row)

#Export tract data to shapefile for storymap
arcpy.CopyFeatures_management(tract_floodfinal, os.path.join(resdir, 'tract_floodfinal.shp'))

#----------------------------------- ADD OTHER ATTRIBUTES -------------------------------------------------------------
#Determine urban-rural status of parcel based on whether it intersects with an Urban Growth Area
fieldInfo = ""
fieldList = arcpy.ListFields(parcel_flood_attri)
for field in fieldList:
    if field.name != "PolyID":
        fieldInfo = fieldInfo + field.name + " " + field.name + " HIDDEN;"
arcpy.MakeFeatureLayer_management(parcel_flood_attri, "joinlyr", field_info=fieldInfo[:-1])
arcpy.SpatialJoin_analysis("joinlyr", urbanareas, 'parcel_urbanareas', 'JOIN_ONE_TO_ONE', match_option = 'INTERSECT')

urbparc = {}
for row in arcpy.da.SearchCursor('parcel_urbanareas', ['PolyID', 'NAME10']):
    urbparc[row[0]] = row[1]
arcpy.AddField_management(parcel_flood_attri, 'NAME10', 'TEXT')
with arcpy.da.UpdateCursor(parcel_flood_attri, ['PolyID', 'NAME10']) as cursor:
    for row in cursor:
        if row[0] in urbparc:
            row[1] = urbparc[row[0]]
            cursor.updateRow(row)


#TO DO LATER
# - try excluding apartment buildings
# - exclude government lodging

