import arcpy
import os
import itertools
import sys
import re
from collections import defaultdict

arcpy.CheckOutExtension("Spatial")
arcpy.env.overwriteOutput = True
arcpy.env.qualifiedFieldNames = False

#Folder structure
rootdir = 'C:/Mathis/ICSL/flood_vulnerability'
datadir = os.path.join(rootdir, 'data')
resdir = os.path.join(rootdir, 'results')
gdb_vulne = os.path.join(resdir,'flood_vulnerability.gdb')

gdb = os.path.join(resdir,'flood_risk.gdb')
if arcpy.Exists(gdb):
    print('Geodatabase already exists')
else:
    arcpy.CreateFileGDB_management(resdir, 'flood_risk.gdb')
arcpy.env.workspace = gdb

FEMAdraftgdb = os.path.join(datadir, 'FEMAdraft_20180920/FEMAdraft.gdb')

#Input data variables
FEMAdata = os.path.join(datadir, 'FEMA_20180819/NFHL_53_20180620/NFHL_53_20180620.gdb')
floodhaz =  os.path.join(FEMAdata, 'S_Fld_Haz_Ar')
USadmin = 'C:\Mathis\ICSL\stormwater\data\USA_adm_gdb\USA_adm.gdb'
USstates = os.path.join(USadmin, 'USA_adm1')
censusblock2010 = 'C:\Mathis\ICSL\stormwater\data\TIGER2017\\tabblock2010_53_pophu\\tabblock2010_53_pophu.shp'

WAdb = os.path.join(datadir, 'WAParcel\StatewideParcels_v2012_e9.2_r1.3\StatewideParcels_v2012_e9.2_r1.3.gdb')#Washington statewide parcel database
parcel = os.path.join(WAdb, 'Land\Parcel')
parcel_name = os.path.join(WAdb, 'Name')
parcel_taxroll = os.path.join(WAdb, 'TaxRoll')
parcel_taxrollname_r = os.path.join(WAdb, 'TaxRollsHaveNames')
StateLU =  os.path.join(WAdb, 'StateLandUse')
provider = os.path.join(WAdb, 'DataProvider')
resid = os.path.join(gdb_vulne, 'parcel_taxrollname_residential')

polycheckjoin = resid + '_polycheck_join'
parcels_blocks = 'parcel_blocks_inters'

#Output variables
floodhazproj = 'S_Fld_Haz_Ar_proj'
parcel_nogeodupli = 'parcel_o5county_nogeodupli'
taxroll_nogeodupli = 'taxroll_nogeodupli'

#Projection (same as WA parcel database): NAD 1983 StatePlane Washington South FIPS 4602 Feet
cs = arcpy.SpatialReference(102749)
#--------------------------------------- ANALYSIS ----------------------------------------------------------------------
#Project FEMA
arcpy.Project_management(floodhaz,floodhazproj, out_coor_system=cs)

#Dissolve flood hazard data to get footprint
arcpy.Dissolve_management(floodhazproj, 'floodhaz_diss',multi_part='SINGLE_PART')

#Create separate layer only with Special Flood Hazard Area (100-year flood zone)
#From https://www.fema.gov/flood-zones (do not include coastal flooding 'V', 'VE', ['V'+str(n) for n in range(1,31)]
#all_codes = set([r[0] for r in arcpy.da.SearchCursor(floodhazproj, ['FLD_ZONE'])])
SFHA_codes = ['A', 'AO','AH', 'AE', 'A99', 'AR', 'AR/AE', 'AR/AO', 'AR/A1-A30', 'AR/A']+['A'+str(n) for n in range(1,31)]
SQLsel = "{0} IN ('{1}')".format('"FLD_ZONE"',"', '".join(map(str, SFHA_codes)) or 'NULL')
arcpy.MakeFeatureLayer_management(floodhazproj, 'floodhaz_lyr')
arcpy.SelectLayerByAttribute_management('floodhaz_lyr', 'NEW_SELECTION',  SQLsel)
arcpy.CopyFeatures_management('floodhaz_lyr', 'floodhaz_SFHA')
#Create separate layer only with SFHA from detailed studies
arcpy.SelectLayerByAttribute_management('floodhaz_lyr', 'SUBSET_SELECTION', "NOT FLD_ZONE='A'")
arcpy.CopyFeatures_management('floodhaz_lyr', 'floodhaz_SFHA_detailed')

#Assess percentage of washington state with FEMA data
arcpy.MakeFeatureLayer_management(USstates, 'WAborder', "{}='Washington'".format('"NAME_1"'))
arcpy.CopyFeatures_management('WAborder', 'WA')
arcpy.Project_management('WA', 'WA_proj', out_coor_system=cs)
arcpy.AddGeometryAttributes_management('WA_proj', 'AREA', Area_Unit='SQUARE_METERS')
arcpy.AlterField_management('WA_proj', 'POLY_AREA', 'WA_AREA', 'WA_AREA')
arcpy.Intersect_analysis(['WA_proj',floodhazproj], 'WAflood_inters')
arcpy.AddGeometryAttributes_management('WAflood_inters', 'AREA', Area_Unit='SQUARE_METERS')
sum([row[0]/((10**6)*row[1]) for row in arcpy.da.SearchCursor('WAflood_inters', ['POLY_AREA','WA_AREA'])]) #FEMA flood hazard layers only cover 34% of WA

#Assess percentage of WA population living in area with FEMA data
arcpy.Project_management(censusblock2010, 'block2010_proj', out_coor_system=cs)
arcpy.AddGeometryAttributes_management('block2010_proj', 'AREA', Area_Unit='SQUARE_METERS')
arcpy.AlterField_management('block2010_proj', 'POLY_AREA', 'BLOCK_AREA', 'BLOCK_AREA')
arcpy.Intersect_analysis(['block2010_proj',floodhazproj], 'blockflood_inters')
arcpy.AddGeometryAttributes_management('blockflood_inters', 'AREA', Area_Unit='SQUARE_METERS')
WApop = sum([row[0] for row in arcpy.da.SearchCursor(censusblock2010, ['POP10'])])
WApop_FEMA = sum([row[0]*row[1]/row[2] for row in arcpy.da.SearchCursor('blockflood_inters', ['POP10','POLY_AREA','BLOCK_AREA'])])
WApop_FEMA/WApop #49% of WA population lives in an area with a FEMA assessment

#-----------------------------------------------------------------------------------------------------------------------
# DOWNSCALE CENSUS
#-----------------------------------------------------------------------------------------------------------------------
#-------------------------Downscale census block population based on parcel information---------------------------------
#Use following as minimum number of households within parcel based on StateLandUseCD
#11: household, single family unit
#12: household, 2-4 units
#13: household, multiunits (>=5)
#14: residential condominiums
#15: mobile home parks or courts
#17: Institutional lodging
#18: All other residential not elsewhere coded

minhousenum = {11: 1, 12: 2, 13: 5, 14: 1, 15: 5, 17: 1, 18: 1}
#Create field with default number of households
arcpy.AddField_management(parcels_blocks, 'HOUSINGMIN', 'FLOAT')
#UpdateCursor using dictionary
with arcpy.da.UpdateCursor(parcels_blocks, ['StateLandUseCD','HOUSINGMIN']) as cursor:
    for row in cursor:
        if row[0] in minhousenum:
            row[1] = minhousenum[row[0]]
        else:
            row[1] = 0
        cursor.updateRow(row)

#Create field for number of TaxRollID associated with it
arcpy.AddField_management(parcels_blocks, 'TAXROLLNUM', 'SHORT')
taxrollnum = defaultdict(int)
for row in arcpy.da.SearchCursor(polycheckjoin, ['PolyID']):
    taxrollnum[row[0]] += 1
with arcpy.da.UpdateCursor(parcels_blocks, ['PolyID','TAXROLLNUM']) as cursor:
    for row in cursor:
        if row[0] in taxrollnum:
            row[1] = taxrollnum[row[0]]
        cursor.updateRow(row)

#Assign maximum of default minimum number of households of # of taxroll records for each parcel
arcpy.AddField_management(parcels_blocks, 'BLCKHOUSEDFLT', 'FLOAT')
blockhousedefault = defaultdict(int)
for row in arcpy.da.SearchCursor(parcels_blocks, ['BLOCKID10','HOUSINGMIN','TAXROLLNUM','BLCKMAJ']):
    blockhousedefault[row[0]] += max(row[1],row[2])*row[3]
#Compute initial estimate of households for each block by summing over all parcels
with arcpy.da.UpdateCursor(parcels_blocks, ['BLOCKID10', 'BLCKHOUSEDFLT']) as cursor:
    for row in cursor:
        row[1] = blockhousedefault[row[0]]
        cursor.updateRow(row)

#Then inspect blocks whose 'BLCKHOUSEDFLT' from parcels over- or underestimate census HOUSING10
arcpy.MakeFeatureLayer_management(parcels_blocks, 'parcels_blocks_lyr', 'BLCKHOUSEDFLT>HOUSING10 AND BLCKMAJ=1 AND HOUSING10>0')
arcpy.CopyFeatures_management('parcels_blocks_lyr', parcels_blocks+'_overblock')
arcpy.MakeFeatureLayer_management(parcels_blocks, 'parcels_blocks_lyr', 'BLCKHOUSEDFLT<HOUSING10')
arcpy.CopyFeatures_management('parcels_blocks_lyr', parcels_blocks+'_underblock')

#Correct discrepancies in household numbers
blockdic = defaultdict(lambda: [0]*15)
with arcpy.da.SearchCursor(parcels_blocks, ['BLOCKID10','HOUSING10','BLCKHOUSEDFLT','BLCKMAJ',
                                            'StateLandUseCD', 'BLCKINTAREA','TAXROLLNUM','HOUSINGMIN']) as cursor:
    for row in cursor:
       if row[1] > 0:
        print(row[0])
        if row[0] not in blockdic:
            blockdic[row[0]][0] = row[2]-row[1] #Difference between initial estimate of # of households and census # of households - 0
        if row[3] > 0:
            if max(row[6],row[7])>0:
                blockdic[row[0]][1] += 1 #Total number of residential parcels - 1
            if row[4] == 83:
                blockdic[row[0]][2] += row[5] #Area for LU 83 (Agriculture classified under current land use) - 2
            elif row[4] == 11:
                blockdic[row[0]][3] += max(row[6],row[7]) #Total households counted in single family parcels (11) - 3
                blockdic[row[0]][4] += 1 #Total number of single family parcels (11) - 4
                if row[6] <= 1:
                    blockdic[row[0]][5] += 1 #Number of single family parcels with min # of households (11) - 5
            elif row[4] == 12:
                blockdic[row[0]][6] += max(row[6], row[7])  # Total households counted in 2-4 family parcels (12) - 6
                blockdic[row[0]][7] += 1 #Total number of 2-4 family parcels (12) - 7
                if row[6] <= 2:
                    blockdic[row[0]][8] += 1 #Number of 2-4 family parcels with min # of households (12) - 8
            elif row[4] == 14:
                blockdic[row[0]][9] += max(row[6], row[7])  # Total households counted in multifamily (>5) parcels (13)  - 9
                blockdic[row[0]][10] += 1 #Total number of multifamily (>5) parcels (13) - 10
                if row[6] <= 5:
                    blockdic[row[0]][11] += 1 #Number of multifamily (>5) parcels with min # of households (13) - 11
            elif row[4] == 15:
                blockdic[row[0]][12] += max(row[6],row[7])  # Total households counted in  mobile home parcels (15)  - 12
                blockdic[row[0]][13] += 1 #Total number of mobile home parcels (15) - 13
                if row[6] <= 5:
                    blockdic[row[0]][14] += 1 #Number of mobile home parcels with min # of households (15) - 14

arcpy.AddField_management(parcels_blocks, 'HOUSINGADJ', 'FLOAT')
arcpy.AddField_management(parcels_blocks, 'POPPERHOUSE', 'SHORT')
arcpy.AddField_management(parcels_blocks, 'PARCELPOP', 'SHORT')


with arcpy.da.UpdateCursor(parcels_blocks,
                           ['BLOCKID10','BLCKMAJ','HOUSING10','BLCKHOUSEDFLT','StateLandUseCD',
                           'HOUSINGMIN','TAXROLLNUM','HOUSINGADJ','BLCKINTAREA','AREA_GEO']) as cursor:
    x=0
    for row in cursor:
        if x<1000:
            if row[1]>0 and row[2]>0 : #If HOUSING10=0, ignore as no population to assign to parcels
                parcel = blockdic[row[0]]
                print(row[0])

                #O ------------- If overestimates number of households in block ---------------------------------------
                if row[3]-row[2] > 0 :
                    print('Overestimates')
                    #O1 - First decrease number of households counted in single-family parcels to 1 (sometimes porches or other structures are counted as taxroll record)
                    if parcel[3]-parcel[4] > 0:
                        single_deduction = min(parcel[0]/(parcel[3]-parcel[4]), 1)
                        parcel[0] = parcel[0] - single_deduction * (parcel[3] - parcel[4])
                        if row[4] == 11 and single_deduction > 0: #If this particular parcel is a single family home, adjust estimated # of households
                            print('Single deduction: {}'.format(single_deduction))
                            indivdown = single_deduction * (row[6]-row[5])
                            row[7] = max(row[5], row[6]) - indivdown
                            blockdic[row[0]][0] = blockdic[row[0]][0] - indivdown  # Adjust difference between estimated # of households and census data

                    #O2 - If still overestimate number of households after decreasing number of properties in single-family household
                    if parcel[0] > 0:
                        print('Still overestimates')
                        if parcel[14] > 0:
                            # Decrease number of households in mobile homes courts/parks with default 5 households as low as needed down to min of 1
                            mobile_deduction = 4 * min(parcel[0]/parcel[14] * 4, 1)
                            parcel[0] = parcel[0] - mobile_deduction * parcel[14]
                            # If this particular parcel is a mobile home court/park with default number of households, adjust estimated # of households
                            if row[4] == 15 and row[6] <= 5:
                                print('Mobile deduction: {}'.format(mobile_deduction))
                                row[7] = 5 - mobile_deduction
                                blockdic[row[0]][0] = blockdic[row[0]][0] - mobile_deduction # Adjust difference between estimate # of households and census data

                    #O3 - If still overestimate number of households
                    if parcel[0] > 0:
                        print('Still overestimates')
                        # Decrease number of households for other parcels which have more taxroll records than the minimum number for that land use
                        rest_over = parcel[6]-2*parcel[7] + parcel[9]-5*parcel[10] + parcel[12]-5*parcel[13]
                        if rest_over>0:
                            rest_deduction = min(parcel[0]/rest_over, 1)
                            parcel[0] = parcel[0] - rest_deduction * rest_over
                        # If this particular parcel is a multifamily parcel with more than minimum # of households, adjust estimated # of households
                            if row[4] in [12, 13, 15] and row[6]-row[5]>0:
                                print('Rest deduction: {}'.format(rest_deduction))
                                restdown = rest_deduction * (row[6]-row[5])
                                row[7] = max(row[5], row[6]) - restdown
                                blockdic[row[0]][0] = blockdic[row[0]][0] - restdown  # Adjust difference between estimated # of households and census data

                    #O4 - If still overestimates, then population will simply be divided by estimated number of households

                #U ------------- If underestimates number of households in block ---------------------------------------------
                if row[3] - row[2] < 0 :
                    print('Underestimates')
                    #U1 - If no residential parcel but agricultural parcels: spread over agricultural parcels LandUseCD 83 where
                    # owner and employee housing is allowed (http://app.leg.wa.gov/RCW/default.aspx?cite=84.34.020)
                    if parcel[1] == 0 :
                        if parcel[2] > 0 :
                            print('Agricultural correction')
                            if row[4] == 83 : #If this particular parcel is an agricultural parcel under code 84.34, adjust estimated # of households
                                row[7] = parcel[0]*row[8]/parcel[2] #Number of households in parcel = overestimate of household # * parcel area within block/total agricultural area of LUCD 83
                        else: #U2 - If no intersecting residential or agricultural parcel, simply spread over the entire census block
                            print('No intersecting residential or agricultural parcel')
                            row[7] = row[2]*row[8]/row[9] # For a given parcel:  #Number of households in parcel= Number of household in census*parcel-block intersection/AREA_GEO (block area)

                    #U3 - If only single family home parcels (if parcel[1] == parcel[4]), divide the number of households equally between parcels

                    #U4 - If some 2-4 family households at minimum, increase their number of households to 4
                    if parcel[8] > 0:
                        multi24_addition = 2 * min(abs(parcel[0])/(parcel[8]*2), 1)
                        parcel[0] = parcel[0] + multi24_addition * (parcel[8])
                        if row[4] == 12 and row[6] <= 2: #If this particular parcel is a 2-4 unit home with minimum # of households, adjust estimated # of households
                            print('Multi24 addition: {}'.format(multi24_addition))
                            row[7] = 2 + multi24_addition
                            blockdic[row[0]][0] = blockdic[row[0]][0] + multi24_addition # Adjust difference between estimated # of households and census data


                    #U5 - If still underestimates number of households and there are multiunit households
                    if parcel[0] < 0:
                        print('Still underestimates')
                        # Increase number of households for bigger multiunit family(> 5 households) and mobile home court parcels equally
                        rest_min = parcel[14] + parcel[11]
                        if rest_min > 0:
                            rest_addition = (rest_min>0) * min(abs(parcel[0])/rest_min, 1)
                            parcel[0] = parcel[0] + rest_addition * rest_min
                            # If this particular parcel is a multifamily parcel or mobile home court with minimum # of households, adjust estimated # of households
                            if row[4] in [13, 15] and row[6]<=row[5]:
                                print('Rest addition: {}'.format(rest_addition))
                                row[7] = row[5] + rest_addition
                                blockdic[row[0]][0] = blockdic[row[0]][0] + rest_addition  # Adjust difference between estimated # of households and census data

            x=x+1
            cursor.updateRow(row)


parcel = blockdic['530150021001008']

#-------------------------------------------------------------------------------------------------------------------------
#Check range of row[7] once done for single family houses and for others (e.g. LU 83)




#To do in the future in agricultural parcels: use NAIP to identify whethere there is impervious area in parcel




#To do in the future: for multiunit household units, relate to number of people in others nearby that are by
# themselves in a block, based on price



#Then dissolve by PolyID
#Then add blocks that don't intersect with any parcel


#Get construction year + renovation year
#---------------Method 2: downscale census block population based on impervious area within parcel----------------------
    #Get US NAIP land cover data
    #With impervious area
    #Without impervious area: lower 10th percentile of block of same size?


#-----------------------------------------------------------------------------------------------------------------------
# INTERSECT WITH FLOOD HAZARD
#-----------------------------------------------------------------------------------------------------------------------
#------- Method 1 - less conservative categorical: if parcel intersects at all with flood zone, count in ---------------

#------- Method 2 - medium categorical: if parcel intersects more than 50% with flood zone, count in -------------------

#------- Method 3 - conservative categorical: if parcel entirely within flood zone, count in ---------------------------

#------- Method 4 - less conservative continuous: population x percentage parcel area that intersects flood zone -------

#------- Method 5 - conservative continuous: population x percentage parcel impervious area that intersects flood zone -