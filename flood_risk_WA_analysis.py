
#To overlay results with imagery in ArcMap, https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryOnly/MapServer is a good source of fast imagery
import arcpy
import os
import itertools
import sys
import re
from collections import defaultdict

arcpy.CheckOutExtension("Spatial")
arcpy.env.overwriteOutput = True
arcpy.env.qualifiedFieldNames = False

#Folder structure
rootdir = 'C:/Mathis/ICSL/flood_vulnerability'
datadir = os.path.join(rootdir, 'data')
resdir = os.path.join(rootdir, 'results')
gdb_vulne = os.path.join(resdir,'flood_vulnerability.gdb')

gdb = os.path.join(resdir,'flood_risk.gdb')
if arcpy.Exists(gdb):
    print('Geodatabase already exists')
else:
    arcpy.CreateFileGDB_management(resdir, 'flood_risk.gdb')
arcpy.env.workspace = gdb

FEMAdraftgdb = os.path.join(datadir, 'FEMAdraft_20180920/FEMAdraft.gdb')

#Input data variables
FEMAdata = os.path.join(datadir, 'FEMA_20180819/NFHL_53_20180620/NFHL_53_20180620.gdb') #FEMA geodatabase
FEMAfloodhaz =  os.path.join(FEMAdata, 'S_Fld_Haz_Ar') #FEMA hazard data
snohopk = os.path.join(datadir, 'SnohomishFloodModel2018_WebMerc20180815.mpk')
USadmin = 'C:\Mathis\ICSL\stormwater\data\USA_adm_gdb\USA_adm.gdb'
USstates = os.path.join(USadmin, 'USA_adm1')
censusblock2010 = os.path.join(datadir, 'TIGER2017\\tabblock2010_53_pophu\\tabblock2010_53_pophu.shp')
blockgroup2010 = os.path.join(datadir, 'TIGER2017\\2010_ACS_5YR_BG_53_WASHINGTON.gdb\\ACS_10_5YR_BG_53_WASHINGTON')
tracts2010 = os.path.join(datadir, 'TIGER2017\\Profile-County_Tract\Profile-County_Tract.gdb\\Tract_2010Census_DP1')

WAdb = os.path.join(datadir, 'WAParcel\StatewideParcels_v2012_e9.2_r1.3\StatewideParcels_v2012_e9.2_r1.3.gdb')#Washington statewide parcel database
parcel = os.path.join(WAdb, 'Land\Parcel')
parcel_name = os.path.join(WAdb, 'Name')
parcel_taxroll = os.path.join(WAdb, 'TaxRoll')
parcel_taxrollname_r = os.path.join(WAdb, 'TaxRollsHaveNames')
StateLU =  os.path.join(WAdb, 'StateLandUse')
provider = os.path.join(WAdb, 'DataProvider')
resid = os.path.join(gdb_vulne, 'parcel_taxrollname_residential')

polycheckjoin = resid + '_polycheck_join'
parcels_blocks = 'parcel_blocks_inters'
blocks_popnoparcel = 'blocks_popnoparcel'

#Output variables
FEMAfloodhazproj = 'S_Fld_Haz_Ar_proj'
fathomsnoho = os.path.join(datadir, 'fathomsnoho')
floodhaz_1980 = os.path.join(fathomsnoho, 'Snoh_100_yr_1980s_Historical_binFT')
floodhaz_2050_low50 = os.path.join(fathomsnoho, 'Snoh_100_yr_2050s_RCP_4_5_Low_50th_binFT')
floodhaz_2050_high50 = os.path.join(fathomsnoho, 'Snoh_100_yr_2050s_RCP_8_5_High_50th_binFT')
flood80_parcel = 'floodhax1980_parcel_inters'
parcel_nogeodupli = 'parcel_o5county_nogeodupli'
taxroll_nogeodupli = 'taxroll_nogeodupli'
parcels_blocksfill = 'parcel_blocks_fill'
bg_proj = 'blockgroup2010_proj'
tracts_proj = 'tracts_WAproj'

#Projection (same as WA parcel database): NAD 1983 StatePlane Washington South FIPS 4602 Feet
cs = arcpy.SpatialReference(102749)

#-----------------------------------------------------------------------------------------------------------------------
# DOWNSCALE CENSUS
#-----------------------------------------------------------------------------------------------------------------------
#------------------------- Method 1: Downscale census block population based on parcel information---------------------------------
#Use following as minimum number of households within parcel based on StateLandUseCD
#11: household, single family unit
#12: household, 2-4 units
#13: household, multiunits (>=5)
#14: residential condominiums
#15: mobile home parks or courts
#17: Institutional lodging
#18: All other residential not elsewhere coded

minhousenum = {11: 1, 12: 2, 13: 5, 14: 1, 15: 5, 17: 1, 18: 1}
#Create field with default number of households
arcpy.AddField_management(parcels_blocks, 'HOUSINGMIN', 'FLOAT')
#UpdateCursor using dictionary
with arcpy.da.UpdateCursor(parcels_blocks, ['StateLandUseCD','HOUSINGMIN']) as cursor:
    for row in cursor:
        if row[0] in minhousenum:
            row[1] = minhousenum[row[0]]
        else:
            row[1] = 0
        cursor.updateRow(row)

#Create field for number of TaxRollID associated with it
arcpy.AddField_management(parcels_blocks, 'TAXROLLNUM', 'SHORT')
taxrollnum = defaultdict(int)
for row in arcpy.da.SearchCursor(polycheckjoin, ['PolyID']):
    taxrollnum[row[0]] += 1
with arcpy.da.UpdateCursor(parcels_blocks, ['PolyID','TAXROLLNUM']) as cursor:
    for row in cursor:
        if row[0] in taxrollnum:
            row[1] = taxrollnum[row[0]]
        cursor.updateRow(row)

#Correct issues that result in 0 population being allocated to some parcels
    #If HOUSING10 > 0 BUT NO PARCEL WITH BLCKMAJ=1, consider that all parcels within block are now included
    #If HOUSING10>0 BUT POP10>0: change HOUSING10 to 1, to be divided among parcels
nullblckmaj = defaultdict(int)
for row in arcpy.da.SearchCursor(parcels_blocks, ['BLOCKID10', 'BLCKMAJ']):
    nullblckmaj[row[0]] += row[1]
with arcpy.da.UpdateCursor(parcels_blocks, ['BLOCKID10', 'BLCKMAJ', 'HOUSING10', 'POP10']) as cursor:
    for row in cursor:
        if nullblckmaj[row[0]] == 0:
            row[1] = 1
            cursor.updateRow(row)
        if row[2]==0 and row[3]>0:
            row[2]=1
            cursor.updateRow(row)

#Assign maximum of (default minimum number of households, # of taxroll records for each parcel)
arcpy.AddField_management(parcels_blocks, 'BLCKHOUSEDFLT', 'FLOAT')
blockhousedefault = defaultdict(int)
for row in arcpy.da.SearchCursor(parcels_blocks, ['BLOCKID10','HOUSINGMIN','TAXROLLNUM','BLCKMAJ']):
    blockhousedefault[row[0]] += max(row[1],row[2])*row[3]
#Compute initial estimate of households for each block by summing over all parcels
with arcpy.da.UpdateCursor(parcels_blocks, ['BLOCKID10', 'BLCKHOUSEDFLT']) as cursor:
    for row in cursor:
        row[1] = blockhousedefault[row[0]]
        cursor.updateRow(row)

#Then inspect blocks whose 'BLCKHOUSEDFLT' from parcels over- or underestimate census HOUSING10
arcpy.MakeFeatureLayer_management(parcels_blocks, 'parcels_blocks_lyr', 'BLCKHOUSEDFLT>HOUSING10 AND BLCKMAJ=1 AND HOUSING10>0')
arcpy.CopyFeatures_management('parcels_blocks_lyr', parcels_blocks+'_overblock')
arcpy.MakeFeatureLayer_management(parcels_blocks, 'parcels_blocks_lyr', 'BLCKHOUSEDFLT<HOUSING10')
arcpy.CopyFeatures_management('parcels_blocks_lyr', parcels_blocks+'_underblock')

#Correct discrepancies in household numbers
arcpy.AddField_management(parcels_blocks, 'HOUSINGADJ', 'FLOAT')

blockdic = defaultdict(lambda: [0]*19)
with arcpy.da.SearchCursor(parcels_blocks, ['BLOCKID10','HOUSING10','BLCKHOUSEDFLT','BLCKMAJ',
                                            'StateLandUseCD', 'StateLandUseCD_1','BLCKINTAREA','TAXROLLNUM','HOUSINGMIN']) as cursor:
    for row in cursor:
       if row[1] > 0:
        print(row[0])
        if row[0] not in blockdic:
            blockdic[row[0]][0] = row[2]-row[1] #Difference between initial estimate of # of households and census # of households - 0
        if row[3] > 0:
            if max(row[7],row[8])>0:
                blockdic[row[0]][1] += 1 #Total number of residential parcels - 1
            if row[4] == 83 or row[5] == 83: #Include both StandLandUseCD and StateLandUseCD_1 as some data have not been well joined (~8,500/3,500,000)
                blockdic[row[0]][2] += row[6] #Area for LU 83 (Agriculture classified under current land use) - 2
            elif row[4] == 11 or row[5] == 11:
                blockdic[row[0]][3] += max(row[7],row[8]) #Total households counted in single family parcels (11) - 3
                blockdic[row[0]][4] += 1 #Total number of single family parcels (11) - 4
                if row[7] <= 1:
                    blockdic[row[0]][5] += 1 #Number of single family parcels with min # of households (11) - 5
            elif row[4] == 12 or row[5] == 12:
                blockdic[row[0]][6] += max(row[7], row[8])  # Total households counted in 2-4 family parcels (12) - 6
                blockdic[row[0]][7] += 1 #Total number of 2-4 family parcels (12) - 7
                if row[7] <= 2:
                    blockdic[row[0]][8] += 1 #Number of 2-4 family parcels with min # of households (12) - 8
            elif row[4] == 13 or row[5] == 13:
                blockdic[row[0]][9] += max(row[7], row[8])  # Total households counted in multifamily (>5) parcels (13)  - 9
                blockdic[row[0]][10] += 1 #Total number of multifamily (>5) parcels (13) - 10
                if row[7] <= 5:
                    blockdic[row[0]][11] += 1 #Number of multifamily (>5) parcels with min # of households (13) - 11
            elif row[4] == 15 or row[5] == 15:
                blockdic[row[0]][12] += max(row[7],row[8])  # Total households counted in  mobile home parcels (15)  - 12
                blockdic[row[0]][13] += 1 #Total number of mobile home parcels (15) - 13
                if row[7] <= 5:
                    blockdic[row[0]][14] += 1 #Number of mobile home parcels with min # of households (15) - 14
            elif row[4] == 18 or row[5] == 18:
                blockdic[row[0]][15] += max(row[7],row[8])  # Total households counted in '18: All other residential not elsewhere coded'(18)  - 15
                blockdic[row[0]][16] += 1 #Total number of non-classified residential parcels (18) - 16
                if row[7] <= 5:
                    blockdic[row[0]][17] += 1 #Number of non-classified residential parcels with min # of households (18) - 17
            blockdic[row[0]][18] += row[6]  # Total intersecting area of parcels included in block - 18

#arcpy.MakeFeatureLayer_management(parcels_blocks, 'test_lyr', "BLOCKID10 = '530330053023013'")
#parcel = [v for v in blockdic['530350814001044']]
with arcpy.da.UpdateCursor(parcels_blocks,
                           ['BLOCKID10','BLCKMAJ','HOUSING10','BLCKHOUSEDFLT','StateLandUseCD',
                           'HOUSINGMIN','TAXROLLNUM','HOUSINGADJ','BLCKINTAREA','AREA_GEO', 'PolyID', 'POP10']) as cursor:
    for row in cursor:
        if row[1]>0 and row[11]>0 : #If HOUSING10=0, ignore as no population to assign to parcels
            parcel = [v for v in blockdic[row[0]]]
            #parcel = blockdic[row[0]] Cannot refer to that as changing parcel then also changes blockdic
            print(row[0])

            #O ------------- If overestimates number of households in block ---------------------------------------
            if row[3]-row[2] > 0:
                #print('Overestimates')
                #O1 - First decrease number of households counted in single-family parcels to 1 (sometimes porches or other structures are counted as taxroll record)
                if parcel[3]-parcel[4] > 0:
                    single_deduction = min(parcel[0]/(parcel[3]-parcel[4]), 1)
                    parcel[0] = parcel[0] - single_deduction * (parcel[3] - parcel[4])
                    if row[4] == 11 and single_deduction > 0 and row[6]>1 : #If this particular parcel is a single family home, adjust estimated # of households
                        #print('Single deduction: {}'.format(single_deduction))
                        indivdown = single_deduction * (row[6]-row[5])
                        row[7] = max(row[5], row[6]) - indivdown

                #O2 - If still overestimate number of households after decreasing number of properties in single-family household
                if parcel[0] > 0:
                    #print('Still overestimates')
                    if parcel[14] > 0:
                        # Decrease number of households in mobile homes courts/parks with default 5 households as low as needed down to min of 1
                        mobile_deduction = 4 * min(parcel[0]/(parcel[14]*4), 1)
                        parcel[0] = parcel[0] - mobile_deduction * parcel[14]
                        # If this particular parcel is a mobile home court/park with default number of households, adjust estimated # of households
                        if row[4] == 15 and row[6] <= 5:
                            #print('Mobile deduction: {}'.format(mobile_deduction))
                            row[7] = 5 - mobile_deduction

                #O3 - If still overestimate number of households
                if parcel[0] > 0:
                    #print('Still overestimates')
                    # Decrease number of households for other parcels which have more taxroll records than the minimum number for that land use
                    rest_over = parcel[6]-2*parcel[7] + parcel[9]-5*parcel[10] + parcel[12]-5*parcel[13] + parcel[15]-parcel[16]
                    if rest_over>0:
                        rest_deduction = min(parcel[0]/rest_over, 1)
                        parcel[0] = parcel[0] - rest_deduction * rest_over
                    # If this particular parcel is a multifamily parcel with more than minimum # of households, adjust estimated # of households
                        if row[4] in [12, 13, 15, 18] and row[6]-row[5]>0:
                            #print('Rest deduction: {}'.format(rest_deduction))
                            restdown = rest_deduction * (row[6]-row[5])
                            row[7] = max(row[5], row[6]) - restdown

                #O4 - If still overestimates, then population will simply be divided by estimated number of households

            #U ------------- If underestimates number of households in block ---------------------------------------------
            if row[3] - row[2] < 0 :
                #print('Underestimates')
                #U1 - If no residential parcel but agricultural parcels: spread over agricultural parcels LandUseCD 83 where
                # owner and employee housing is allowed (http://app.leg.wa.gov/RCW/default.aspx?cite=84.34.020)
                if parcel[1] == 0:
                    if parcel[2] > 0 :
                        #print('Agricultural correction')
                        if row[4] == 83 : #If this particular parcel is an agricultural parcel under code 84.34, adjust estimated # of households
                            row[7] = abs(parcel[0])*row[8]/parcel[2] #Number of households in parcel = underestimate of household # * parcel area within block/total agricultural area of LUCD 83
                    else: #U2 - If no intersecting residential or agricultural parcel, simply spread over the entire census block
                        #print('No intersecting residential or agricultural parcel')
                        row[7] = row[2]*row[8]/parcel[18] # For a given parcel:  #Number of households in parcel= Number of household in census*parcelblock intersection/AREA_GEO (block area)

                #U3 - If only single family home parcels (if parcel[1] == parcel[4]), divide the number of households equally between parcels

                #U4 - If some 2-4 family households at minimum, increase their number of households to 4
                if parcel[8] > 0:
                    multi24_addition = 2 * min(abs(parcel[0])/(parcel[8]*2), 1)
                    parcel[0] = parcel[0] + multi24_addition * (parcel[8])
                    if row[4] == 12 and row[6] <= 2: #If this particular parcel is a 2-4 unit home with minimum # of households, adjust estimated # of households
                        #print('Multi24 addition: {}'.format(multi24_addition))
                        row[7] = 2 + multi24_addition

                #U5 - If still underestimates number of households and there are multiunit households
                if parcel[0] < 0:
                    #print('Still underestimates')
                    # Increase number of households for bigger multiunit family(> 5 households) and mobile home court parcels equally
                    rest_min = parcel[14] + parcel[11]
                    if rest_min > 0:
                        rest_addition = abs(parcel[0])/rest_min
                        parcel[0] = parcel[0] + rest_addition * rest_min
                        # If this particular parcel is a multifamily parcel or mobile home court with minimum # of households, adjust estimated # of households
                        if row[4] in [13, 15] and row[6]<=row[5]:
                            #print('Rest addition: {}'.format(rest_addition))
                            row[7] = row[5] + rest_addition

            #Shift single census block household from PolyID 431000114513 to 431000164337 (Monroe Correctional Complex with > 2000 people)
            if row[9] == '431000114513':
                row[7] = 0
            elif row[9] == '431000164337':
                row[7] = 1
            if row[9] == '417000565595':
                row[7] = None
            elif row[9] == '417000196063':
                row[7] = 329
            cursor.updateRow(row)

#Inspect results
arcpy.MakeFeatureLayer_management(parcels_blocks, 'parcels_blocks_lyr', 'BLCKHOUSEDFLT>HOUSING10 AND BLCKMAJ=1 AND HOUSING10>0' \
                                                                        'AND (HOUSINGMIN> 0 OR HOUSINGADJ>0)')
arcpy.CopyFeatures_management('parcels_blocks_lyr', parcels_blocks+'_overblockadj')
arcpy.MakeFeatureLayer_management(parcels_blocks, 'parcels_blocks_lyr', 'BLCKHOUSEDFLT<HOUSING10 AND BLCKMAJ=1' \
                                                                        'AND (HOUSINGMIN> 0 OR HOUSINGADJ>0)')
arcpy.CopyFeatures_management('parcels_blocks_lyr', parcels_blocks+'_underblockadj')

#Assign pop/households to each block for inspection
arcpy.AddField_management(parcels_blocks, 'BLCKPOPPERHOUSE', 'FLOAT')
#Compute population per household given adjusted parcel household numbers
blockhouseadj = defaultdict(float)
for row in arcpy.da.SearchCursor(parcels_blocks, ['BLOCKID10','HOUSINGADJ','HOUSINGMIN','TAXROLLNUM','BLCKMAJ']):
    print(row[0])
    if row[1] is not None:
        blockhouseadj[row[0]] += row[1] * row[4]
    else:
        blockhouseadj[row[0]] += max(row[2],row[3])*row[4]
#Compute adjusted estimate of population per household for each block
with arcpy.da.UpdateCursor(parcels_blocks, ['BLOCKID10', 'BLCKPOPPERHOUSE', 'POP10']) as cursor:
    for row in cursor:
        print(row[0])
        if blockhouseadj[row[0]]>0:
            row[1] = row[2]/blockhouseadj[row[0]]
        cursor.updateRow(row)
#Lots of the very high BLCKPOPPERHOUSE values also come from Correctional Complexes (e.g. King County Adult detention), and University residences, etc.

#Assign population number to each parcel
arcpy.AddField_management(parcels_blocks, 'PARCELPOP', 'FLOAT')
with arcpy.da.UpdateCursor(parcels_blocks, ['POP10','PARCELPOP','BLCKPOPPERHOUSE', 'HOUSINGADJ',
                                            'BLCKMAJ','HOUSINGMIN','TAXROLLNUM']) as cursor:
    for row in cursor:
        if row[0] > 0:
            if row[2] is not None:
                if row[3] is not None:
                    row[1] = row[2]*row[3]*row[4]
                else:
                    row[1] = max(row[5],row[6])*row[2]*row[4]
            else:
                row[1] = 0
        else:
            row[1] = 0
        cursor.updateRow(row)

#Inspected the 400 parcels with the highest PARCELPOP, only 1 assigned to the wrong neighboring parcel

arcpy.CopyFeatures_management(parcels_blocks, parcels_blocks+'_copy')

#Then add blocks that don't intersect with any parcel
arcpy.Merge_management([parcels_blocks, blocks_popnoparcel], output = parcels_blocksfill)
with arcpy.da.UpdateCursor(parcels_blocksfill, ['PARCELPOP', 'POP10']) as cursor:
    for row in cursor:
        if row[0] is None:
            row[0] = row[1]
            cursor.updateRow(row)

#Make sure that sum of parcel populations adds up to block population
arcpy.AddField_management(parcels_blocksfill, 'POP10_DIF', field_type = 'FLOAT')
POP10_ESTdict = defaultdict(float)
for row in arcpy.da.SearchCursor(parcels_blocksfill, ['BLOCKID10', 'PARCELPOP']):
    print(row[0])
    POP10_ESTdict[row[0]] += row[1]
with arcpy.da.UpdateCursor(parcels_blocksfill, ['BLOCKID10', 'POP10','POP10_DIF']) as cursor:
    for row in cursor:
        row[2] = POP10_ESTdict[row[0]] - row[1]
        cursor.updateRow(row)
arcpy.MakeFeatureLayer_management(parcels_blocksfill, 'pbfill_lyr', 'POP10_DIF>=1 OR POP10_DIF<=-1')
arcpy.CopyFeatures_management('pbfill_lyr', parcels_blocksfill+'_problem')

#To do in the future for downscaling census:
#   - in agricultural parcels: use NAIP to identify where there is impervious area in parcel
#   - for multiunit household units, relate to number of people in others nearby that are by themselves in a block, based on price
#   - create range of population in parcel
#   - remove any area that's permanently water covered from calculations (with NHD and other water masks e.g. Pekel)


#TO DO
#---------------Method 2: downscale census block population based on impervious area within census block ---------------

#-----------------------------------------------------------------------------------------------------------------------
# FORMAT FOR RACE/ETHNICITY ANALYSIS
#-----------------------------------------------------------------------------------------------------------------------
#Project block group
arcpy.Project_management(blockgroup2010, bg_proj, cs)
#Project tracts
arcpy.MakeFeatureLayer_management(tracts2010, 'tractslyr', "GEOID10 LIKE '53%'")
arcpy.CopyFeatures_management('tractslyr', 'tracts_WA')
arcpy.Project_management('tracts_WA', tracts_proj, cs)

#Make new field called GEOID10 in parcels_blocks: 0:11 of BLOCKID10
arcpy.AddField_management(parcels_blocksfill, 'GEOID10_bg', field_type='TEXT')
arcpy.CalculateField_management(parcels_blocksfill, 'GEOID10_bg', expression = '!BLOCKID10![0:12]', expression_type='PYTHON')
arcpy.AddField_management(parcels_blocksfill, 'GEOID10_t', field_type='TEXT')
arcpy.CalculateField_management(parcels_blocksfill, 'GEOID10_t', expression = '!BLOCKID10![0:11]', expression_type='PYTHON')

#Export table to csv
fields= arcpy.ListFields(parcels_blocksfill)
fieldinfo = arcpy.FieldInfo()
fieldsel = ['GEOID10_bg', 'GEOID10_t','BLOCKID10', 'PolyID', 'StateLandUseCD', 'BLCKMAJ', 'HOUSINGMIN', 'TAXROLLNUM', 'HOUSINGADJ',
            'BLCKPOPPERHOUSE', 'PARCELPOP']
for field in fields:
    if field.name in fieldsel:
        print(field.name)
        fieldinfo.addField(field.name, field.name, "VISIBLE", "")
    else:
        fieldinfo.addField(field.name, field.name, "HIDDEN", "")
arcpy.MakeTableView_management(parcels_blocksfill, 'parcelblock_tab', field_info = fieldinfo)
arcpy.CopyRows_management('parcelblock_tab', os.path.join(resdir, 'parcels_blocksfill_subfield.csv'))

#-----------------------------------------------------------------------------------------------------------------------
# INTERSECT WITH FLOOD HAZARD
#-----------------------------------------------------------------------------------------------------------------------
#Extract snohomish flood hazard data from map package
if not arcpy.Exists(fathomsnoho):
    print('Create new directory: '+ fathomsnoho)
    os.mkdir(fathomsnoho)
    arcpy.ExtractPackage_management(snohopk, fathomsnoho)

#Project parcel data to same cs as flood hazard data
arcpy.Describe(floodhaz_1980).SpatialReference

#Subset raster to exclude 999 (permanent water features)
#Intersect blocksfill with floodhaz to identify overlay area + average water depth
arcpy.Intersect_analysis([parcels_blocksfill, floodhaz_1980], flood80_parcel)

#------- Method 1 - less conservative categorical: if parcel intersects at all with flood zone, count in ---------------


#------- Method 2 - medium categorical: if parcel intersects more than 50% with flood zone, count in -------------------

#------- Method 3 - conservative categorical: if parcel entirely within flood zone, count in ---------------------------

#------- Method 4 - less conservative continuous: population x percentage parcel area that intersects flood zone -------

#------- Method 5 - conservative continuous: population x percentage parcel impervious area that intersects flood zone -


#-----------------------------------------------------------------------------------------------------------------------
# ANALYSIS OF FEMA DATA
#-----------------------------------------------------------------------------------------------------------------------
#Project FEMA
arcpy.Project_management(FEMAfloodhaz, FEMAfloodhazproj, out_coor_system=cs)
#Dissolve flood hazard data to get footprint
arcpy.Dissolve_management(FEMAfloodhazproj, 'FEMAfloodhaz_diss',multi_part='SINGLE_PART')

#Create separate layer only with Special Flood Hazard Area (100-year flood zone)
#From https://www.fema.gov/flood-zones (do not include coastal flooding 'V', 'VE', ['V'+str(n) for n in range(1,31)]
#all_codes = set([r[0] for r in arcpy.da.SearchCursor(floodhazproj, ['FLD_ZONE'])])
SFHA_codes = ['A', 'AO','AH', 'AE', 'A99', 'AR', 'AR/AE', 'AR/AO', 'AR/A1-A30', 'AR/A']+['A'+str(n) for n in range(1,31)]
SQLsel = "{0} IN ('{1}')".format('"FLD_ZONE"',"', '".join(map(str, SFHA_codes)) or 'NULL')
arcpy.MakeFeatureLayer_management(FEMAfloodhazproj, 'FEMAfloodhaz_lyr')
arcpy.SelectLayerByAttribute_management('FEMAfloodhaz_lyr', 'NEW_SELECTION',  SQLsel)
arcpy.CopyFeatures_management('FEMAfloodhaz_lyr', 'FEMAfloodhaz_SFHA')
#Create separate layer only with SFHA from detailed studies
arcpy.SelectLayerByAttribute_management('FEMAfloodhaz_lyr', 'SUBSET_SELECTION', "NOT FLD_ZONE='A'")
arcpy.CopyFeatures_management('FEMAfloodhaz_lyr', 'FEMAfloodhaz_SFHA_detailed')

#Assess percentage of washington state with FEMA data
arcpy.MakeFeatureLayer_management(USstates, 'WAborder', "{}='Washington'".format('"NAME_1"'))
arcpy.CopyFeatures_management('WAborder', 'WA')
arcpy.Project_management('WA', 'WA_proj', out_coor_system=cs)
arcpy.AddGeometryAttributes_management('WA_proj', 'AREA', Area_Unit='SQUARE_METERS')
arcpy.AlterField_management('WA_proj', 'POLY_AREA', 'WA_AREA', 'WA_AREA')
arcpy.Intersect_analysis(['WA_proj',FEMAfloodhazproj], 'WAFEMAflood_inters')
arcpy.AddGeometryAttributes_management('WAFEMAflood_inters', 'AREA', Area_Unit='SQUARE_METERS')
sum([row[0]/((10**6)*row[1]) for row in arcpy.da.SearchCursor('WAFEMAflood_inters', ['POLY_AREA','WA_AREA'])]) #FEMA flood hazard layers only cover 34% of WA

#Assess percentage of WA population living in area with FEMA data
arcpy.Project_management(censusblock2010, 'block2010_proj', out_coor_system=cs)
arcpy.AddGeometryAttributes_management('block2010_proj', 'AREA', Area_Unit='SQUARE_METERS')
arcpy.AlterField_management('block2010_proj', 'POLY_AREA', 'BLOCK_AREA', 'BLOCK_AREA')
arcpy.Intersect_analysis(['block2010_proj',FEMAfloodhazproj], 'blockFEMAflood_inters')
arcpy.AddGeometryAttributes_management('blockFEMAflood_inters', 'AREA', Area_Unit='SQUARE_METERS')
WApop = sum([row[0] for row in arcpy.da.SearchCursor(censusblock2010, ['POP10'])])
WApop_FEMA = sum([row[0]*row[1]/row[2] for row in arcpy.da.SearchCursor('blockFEMAflood_inters', ['POP10','POLY_AREA','BLOCK_AREA'])])
WApop_FEMA/WApop #49% of WA population lives in an area with a FEMA assessment