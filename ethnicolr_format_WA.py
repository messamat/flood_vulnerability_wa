#Intall python 3.5
#Add to list of interpreters in Pycharm https://www.jetbrains.com/help/pycharm-edu/adding-existing-virtual-environment.html
#Install ethnicolr in pycharm settings

import arcpy
import pandas as pd
import numpy as np
import os
import sys
import re
import itertools

arcpy.env.qualifiedFieldNames = False
arcpy.env.overwriteOutput = True

rootdir = 'C:\Mathis\ICSL\\flood_vulnerability'
datadir = os.path.join(rootdir,'data\\')
resdir = os.path.join(rootdir,'results\\')

gdb = os.path.join(resdir,'flood_vulnerability.gdb')
if arcpy.Exists(gdb):
    print('Geodatabase already exists')
else:
    arcpy.CreateFileGDB_management(resdir, 'flood_vulnerability.gdb')
arcpy.env.workspace = gdb

#----------------------------------
# Import data
#----------------------------------
WAdb = os.path.join(datadir, 'WAParcel\StatewideParcels_v2012_e9.2_r1.3\StatewideParcels_v2012_e9.2_r1.3.gdb')#Washington statewide parcel database
parcel = os.path.join(WAdb, 'Land\Parcel')
parcel_name = os.path.join(WAdb, 'Name')
parcel_taxroll = os.path.join(WAdb, 'TaxRoll')
parcel_taxrollname_r = os.path.join(WAdb, 'TaxRollsHaveNames')
StateLU =  os.path.join(WAdb, 'StateLandUse')
provider = os.path.join(WAdb, 'DataProvider')

#Common variables
resid = 'parcel_taxrollname_residential'
resid_nonull = 'parcel_taxrollname_residential_nonull'
resid_indiv = 'parcel_taxrollname_residindiv'

#Join taxroll attributes to parcel polygons (one-to-many relationship from parcel to taxrollIDs so require query
arcpy.MakeFeatureLayer_management(parcel, 'parcel_lyr')
try:
    SQLjoin = 'Parcel.PolyID = TaxRoll.PolyID'
    # Make Query Table...
    arcpy.MakeQueryTable_management([parcel, parcel_taxroll], 'parcel_taxroll_query', "ADD_VIRTUAL_KEY_FIELD", where_clause=SQLjoin)
except Exception as err:
    print(err.args[0])
arcpy.CopyFeatures_management('parcel_taxroll_query', 'parcel_taxroll')

#Join owner names to parcel taxroll attributes
arcpy.MakeTableView_management(parcel_taxroll, 'parcel_taxroll_lyr')
arcpy.AddJoin_management('parcel_taxroll_lyr','TaxRollID',parcel_taxrollname_r,'TaxRollID')
arcpy.AddJoin_management('parcel_taxroll_lyr','TaxRollsHaveNames.NameID',parcel_name,'NameID')
arcpy.CopyRows_management('parcel_taxroll_lyr', 'parcel_taxrollname')
#Join parcel attributes
arcpy.JoinField_management('parcel_taxrollname', 'TaxRollID', 'parcel_taxroll', join_field='TaxRollID',
                           fields=[f.name for f in arcpy.ListFields(parcel)][2:-3])

#Identify residential land use codes, excluding vacation and hotels
arcpy.Exists(StateLU)
arcpy.MakeTableView_management(StateLU, 'StateLU_lyr', where_clause="Category='RESIDENTIAL'")
LUsel = {}
for row in arcpy.da.SearchCursor('StateLU_lyr',['StateLandUseCD','Name']):
    print(row[0])
    if row[1] not in ['Vacation and cabin','Hotels/motels']:
        LUsel[row[0]]=row[1]

#Only keep residential parcels and remove all records with no owner name
#[f.name for f in arcpy.ListFields('parcel_taxrollname')]
arcpy.MakeTableView_management('parcel_taxrollname', 'parcel_taxrollname_lyr')
SQLsel = '"StateLandUseCD" IN ({})'.format(', '.join(map(str, LUsel.keys())) or 'NULL')
arcpy.SelectLayerByAttribute_management('parcel_taxrollname_lyr', 'NEW_SELECTION', SQLsel)
arcpy.CopyRows_management('parcel_taxrollname_lyr', resid)

#Remove all records with no owner name
arcpy.SelectLayerByAttribute_management('parcel_taxrollname_lyr', 'SUBSET_SELECTION', 'NOT "Name" IS NULL')
arcpy.CopyRows_management('parcel_taxrollname_lyr', resid_nonull)
#pd.DataFrame(arcpy.da.TableToNumPyArray(resid, '*', skip_nulls=False, null_value=-99999)) #insufficient memory

#------------------------------------------------------------------------------------------------------
# PARSE NAMES
#------------------------------------------------------------------------------------------------------
# For good guide on regex: https://docs.python.org/3/howto/regex.html
#----------------------------------------------------------------
#Only keep individual owners rather than companies or institutions. If doesn't work, try: https://github.com/datamade/probablepeople
#For now, use a lot of suffixes used in training probable people

#Functions to create regex patterns out of different word types: single words, abbrevations, and acronyms
def pattern_word(word, plural):
    if isinstance(word, str):
        #rword = re.escape(word)
        if plural is True:
            reg_word = r'\b' + word + r'S?\b'
        else:
            reg_word = r'\b' + word + r'\b'
        return reg_word
    else:
        raise Warning('input is not a string')
def pattern_abbrev(word):
    if isinstance(word, str):
        #rword = re.escape(word)
        reg_word = r'\b' + word + r'\b[.]?'
        return reg_word
    else:
        raise Warning('input is not a string')
def pattern_acronym(word):
    if isinstance(word, str):
        #rword = re.escape(word)
        reg_word = r'\s'+r'\W?'.join([i for i in word])+'([.]?[*]?\s*|\/)'
        return reg_word
    else:
        raise Warning('input is not a string')

#COMPANIES#
#Assign company names to word categories to be converted to regex pattern
private_words = ['ENTERPRISE','SHARE','COMPANY','PARTNER', 'PARTNERSHIP','PRTNRSHP','PTRN','CORPORATION','MORTGAGE','INVESTMENT','INVEST[a-zA-Z]*','ASSOCIATE',
         'BROKERAGE','COMPANY','CONSULTING','CONSULTANT','REALTY','ORGANIZATION','GROUP','SERVICE','PROPERTY','APT','MANAGEMENT',
         'APARTMENT','CONDOMINIUM','PROPERTIES','LIFE\s?EST','LF\s?EST','ESTATE','RANCH','HOLDING','CAPITAL','FUND','SUBSIDIARY','SUBSIDIARIES',
         'DEVELOPMENT','LIMITED','BLDG','CONSTRUCTION', 'UNITED']
private_word_noplural = ['BANK']
private_abbrev = ['ASS','CO','CORP','INC','ORG']
private_acro = ['LTD','LP','LLP','LLC','PLC','VC','RPBM']

#Convert all words into regex patterns
private_reglist = [pattern_word(w, plural=True) for w in private_words]+\
                  [pattern_abbrev(w) for w in private_abbrev]+\
                  [pattern_acronym(w) for w in private_acro]+\
                  [pattern_word(w, plural=False) for w in private_word_noplural]
#Create an overall pattern looking for any of these patterns
private_regunion = "(" + "|".join(private_reglist) + ")"

#OTHER INSTITUTIONS#
inst_words = ['CHURCH','DIOCESE','COUNTY','CTY','CITY','TOWN','MUNICIPAL','DISTRICT','SCHOOL','COLLEGE','UNIVERSITY','INSTITUTE','ACADEMY',
              'COLATION','UNITED\s?STATES','INTL','NATL','DEPT','ASSN','AMERICAN','EDUCATIONAL','TRANSIT','HEALTH','CATHOLIC',
              'PROTESTANT','MUSLIM','BUDDHIST','JEWISH','ORTHODOX','BAPTIST','FAMILY','NORTHWEST','COMMUNITY','AFFAIR',
              'LIBRARY','FOUNDATION', 'FEDERAL','FEDERATION','SECRETARY','NATIONAL','ASSOCIATION','HOUSE','HOUSING','VACANT','UNION','HOSPITAL',
              'CENTER','CTR','RETIREMENT','UTILIT[A-Z]*','RESOURCE','HOME','FARM','ASSOC','POLICE','COUNCIL','OFFICE',
              'BUREAU','DEPARTMENT','DPT','STATE','CHAPTER','MARKET','TRIBE','SOCIETY','ALLIANCE','AUTHORITY','CLINIC',
              'GOVERNMENT','GOVT','COMMITTEE','LOCAL','ACADEMY','ASSEMBLY','AGENCY','GOD','MISSION','OF', 'FOR', 'IN', 'THE'] #add owners, homeowners
inst_reglist = [pattern_word(w, plural=True) for w in inst_words]+\
              [pattern_abbrev('ASSOC')]+\
              [pattern_acronym(w) for w in ['PAC','USA']]
inst_regunion = "(" + "|".join(inst_reglist) + ")"


#TRUST#
trust_words = ['TTEE','TTE','TR','REV\s?TR','TRT','TST','TRST','TRSTE','TRTEE','TRSES','TRTEES','TRSTEE','TSTEE',
               'TRUSTEE','TRUST','TRU','TRUSTE','TRUSTESS','GRANTEES',"DON[']T\sMAIL", 'UNKNOWN']
trust_reglist = [pattern_word(w, plural=True) for w in trust_words]
trust_regunion = "(" + "|".join(trust_reglist) + ")"

#Filter out all non individuals (To do: assess percentage of people in census removed due to keywords (e.g. town, church, etc. as last names)
nonindiv_filter = re.compile("|".join([private_regunion,inst_regunion,trust_regunion])+'|[0-9]+', re.IGNORECASE) #also remove any party name containing numbers
arcpy.AddField_management(resid_nonull, 'OwnerTypeMM', field_type='text')
with arcpy.da.UpdateCursor(resid_nonull, ['Name','OwnerTypeMM']) as cursor:
    for row in cursor:
        if nonindiv_filter.search(row[0]) is not None:
            row[1] = 'non_individual'
        else:
            row[1] = 'individual'
        cursor.updateRow(row)
arcpy.MakeTableView_management(resid_nonull, 'residential_nonull_lyr', where_clause="OwnerTypeMM='individual'")
arcpy.CopyRows_management('residential_nonull_lyr', resid_indiv)
arcpy.MakeTableView_management(resid_nonull, 'residential_nonull_lyr', where_clause="OwnerTypeMM='non_individual'")
arcpy.CopyRows_management('residential_nonull_lyr', 'parcel_taxrollname_residnonindiv')

#Make copy of owner name to edit for parsing
arcpy.AddField_management(resid_indiv, field_name='Name_copy', field_type='text')
arcpy.CalculateField_management(resid_indiv, 'Name_copy',"!Name!","PYTHON")

# #Then check whether the string has &,/,\, or OR, AND, VS, +
# if so, split it at each of these characters
def delete_empty_fields(fc, fieldlist):
    """Delete fields with only nulls, None, spaces, etc. within a provided list of fields
    Adapted from https://gis.stackexchange.com/questions/204684/delete-empty-and-null-fields-using-arcpy"""
    for field in fieldlist:
        print(field)
        keep = False
        for row in arcpy.da.UpdateCursor(fc, [field]):
            if row[0] is not None or \
                    (isinstance(row[0], basestring) and\
                     (row[0].lower.strip() != '' or\
                           row[0] != '<null>')):
                keep = True
                break
        if keep is False:
            print('Deleting: '+field)
            arcpy.DeleteField_management(fc, field)
def regex_field_split(fc, splitfield, regx, maxsplit, field_keyword):
    "Split a field into multiple fields based on a regular expression, the equivalent of panda.str.split()"
    party_fieldlist = ['{0}{1}'.format(field_keyword, i) for i in range(1,maxsplit+1)] #Fields to split string among
    for field in party_fieldlist: #create fields
        if field not in [f.name for f in arcpy.ListFields(fc)]: #first make sure it's not really there, skip if it is
            arcpy.AddField_management(fc, field, field_type='text')
    regex_letter = re.compile(r'[A-Z]',re.IGNORECASE)
    with arcpy.da.UpdateCursor(fc, [splitfield]+party_fieldlist) as cursor:
        for row in cursor: #For each row
            if regex_letter.search(row[0]) is not None: #Make sure that owner name is not empty
                #print(row[0])
                splitparty = regx.split(row[0], maxsplit) #Split owners' names
                f=1
                for i in range(len(splitparty)): #Add each owner party to a separate field, removing leading and trailing spaces
                    if regex_letter.search(splitparty[i]) is not None: #Make sure that the field is not empty
                        row[f]=splitparty[i].strip()
                        f=f+1
                cursor.updateRow(row)
            else:
                cursor.deleteRow() #If owner name is empty, delete row
    delete_empty_fields(fc, party_fieldlist) #Remove fields that didn't get filled

maxsplit = 10
owner_split = re.compile(r'[&]|\/|\\|\s{2,}|[+]|\bOR\b|\bAND\b|\bVS\b', re.IGNORECASE)
mainkey = 'party'
regex_field_split(fc=resid_indiv, splitfield='Name_copy',regx=owner_split, maxsplit=10, field_keyword=mainkey)

########################################################################################################################
def regex_field_extract(fc, targetfield_regx, newfield_keyword, regx):
    '''Takes a regex to match fields from which to extract keywords based on another regex, write the keywords to a new
    field, and then remove these keywords from the original field. For instance, can remove JR from Donald Trump JR'''
    mainkeyfields = [f.name for f in arcpy.ListFields(fc) if
                     targetfield_regx.search(f.name)]  # List of party fields
    for field in mainkeyfields:  #For each subparty number
        field_suffix = '{0}_{1}'.format(field, newfield_keyword) #new field name
        arcpy.AddField_management(fc, field_suffix, field_type='text') #Create new field
        with arcpy.da.UpdateCursor(fc, [field, field_suffix]) as cursor:
            for row in cursor:  # For each row
                #print(row[0])
                try:
                    suffix_search = regx.findall(row[0]) #Get all keyword matches in a list
                    if suffix_search: #If list is not empty (i.e. there is a keyword in subparty name)
                        row[1]= ','.join(suffix_search) #Write matched keywords to new field
                        row[0]=regx.sub('', row[0]).strip() #Remove keyword from original subparty name to clear it up for future steps
                        cursor.updateRow(row)
                except:
                    e = sys.exc_info()[1]
                    #print(e.args[0])
    delete_empty_fields(fc, ['{0}_{1}'.format(field, newfield_keyword) for field in mainkeyfields]) #Delete empty keyword fields

#Extract hereditary suffixes, write it to separate field and delete from subparty names
regx_suffix = re.compile(r'\bJR\b|\bSR\b|\bII\b|\bIII\b', re.IGNORECASE) #Regex to match hereditary suffixes
targetfield = re.compile(r'^{0}\d+$'.format(mainkey))
regex_field_extract(resid_indiv, targetfield, 'suffix', regx_suffix)

#Extract honorary prefixes
prefix_list = ['MC', 'MAC', 'VAN', 'DER', 'VON', 'VAN\s?DER', 'DU', 'DO', 'DA', 'DEL', 'DE', 'DU','DOS','DEN','ST',
                   'LA','SAN', 'AL', 'EL','DI','O', 'TEN', 'ZUM', 'ZU', 'NA', 'AF'] #Create list of name suffixes and include the next word? Van, Al (when three full words or more Al adhad mohammed)
prefix_str = '|'.join([pattern_word(w, plural=False) for w in prefix_list])
regx_prefix= re.compile(prefix_str, re.IGNORECASE) #Regex to match honorary prefixes
targetfield = re.compile(r'^{0}\d+$'.format(mainkey))
regex_field_extract(resid_indiv, targetfield, 'prefix', regx_prefix)

#Extract non-name keywords
nonname_extra = ['ET\s?AL','ET\s?UX','H[/]?W','JTW?ROS','[&]\s?SONS','TIC','ET\s?VIR']
nonname_extra_str = '|'.join([pattern_word(w, plural=False) for w in nonname_extra])
regx_extra = re.compile(nonname_extra_str, re.IGNORECASE)
targetfield = re.compile(r'^{0}\d+$'.format(mainkey))
regex_field_extract(resid_indiv, targetfield, 'extra', regx_extra)

try_str ='BERRY DONALD P (ETAL)'
regx_extra.findall(try_str)

#Extract content in parenthesis or quotes
nickname_str = r"(\(|\"|\') .+ ([)]|\"|\') |" \
               r"(\(|\") .+ (\s|$)      |" \
               r"(^|\s)     .+ ([)]|\")  " #Do not include ' in the one-sided match to avoid O'MAHA D'ANGELO getting picked up
regx_nickname = re.compile(nickname_str, re.IGNORECASE | re.VERBOSE)

#Delete all special characters aside from
"[']|[-]" #To include O'NEALS and L'AMARCA or compound names

#Create first and second last name fields for each party
providerID = {}
for row in arcpy.da.SearchCursor(provider, ['DataProviderID','Name']):
    providerID[row[0]] = row[1]




#When more than last and first full names: check for
titles_list = {'MD','DR','PHD',}

compound_names = ['LYNN', 'LYNNE', 'ANN', 'ANNE', 'JEAN', 'JO', 'MARIE', 'MARIA']

# #Divide first name by space or comma or AKA
subparty_split = re.compile(r'\s(?!$)|[,]\s?|\s\bAKA\b\s')












# #Subparty1, first column
# #Find single letter, delete content and push all subsequent columns left until first full word
# pdat_housingindiv['subparty1_{}'.format(splitsubparty.shape[1]+1)] = np.nan
#
#
# mask = pdat_housingindiv.subparty1_1.str.len() == 1 | pdat_housingindiv.subparty1_1.isnull()
# while pdat_housingindiv.loc[mask, newcols].shape[0] > 0:
#     pdat_housingindiv.loc[mask, newcols] = \
#         pdat_housingindiv.loc[mask, newcols].astype(str).shift(-1, axis=1)
# pdat_housingindiv[pdat_housingindiv[newcols].isnull().all(axis=1)]

#Ignore repetitions within parties 'FLAMENCO ANGELA FLAMENCO ANGELA'
#'space - space' preceded by a single letter means new person, not hyphenated name
#'space - space' with full words on both sides are wrongly hyphenated last names or first names
#If only one word in first subparty, and only one word in the second, then only one party's last and first name or vice versa depending on county



################################################################
#Check if one of the names in party 2+ match a last name in party 1 or vice-versa depending on firstlast order
#Keep names separated by special character (-, ') unless otherwise pointed out in county system
#When only a letter in a party past #1, assign it as a first name initial with the last name of the previous party number

#Flag single parties with more than 4 things - quite likely not a person e.g. 'Schoessler fam rev liv tr'

#Analyze address line 1 as well, getting rid of non-indivs, numbers, and UNKNOWN
#Keep record but remove  C/O, %, ATTN


def detect_and_fix_two_part_surname(self, args):
    """
    This detects common family name prefixes and joins them to the last name,
    so names like "De Kuyper" don't end up with "De" as a middle name.
    """
    i = 0
    while i < len(args) - 1:
        if args[i].lower() in self.family_name_prefixes:
            args[i] = ' '.join(args[i:i + 2])
            del (args[i + 1])
            break
        else:
            i += 1
