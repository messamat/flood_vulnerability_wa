#Intall python 3.5
#Add to list of interpreters in Pycharm https://www.jetbrains.com/help/pycharm-edu/adding-existing-virtual-environment.html
#Install ethnicolr in pycharm settings

import arcpy
import pandas as pd
import numpy as np
import os
import re
import itertools

arcpy.env.qualifiedFieldNames = False
arcpy.env.overwriteOutput = True

rootdir = 'C:\Mathis\ICSL\\flood_vulnerability'
datadir = os.path.join(rootdir,'data\\')
resdir = os.path.join(rootdir,'results\\')

gdb = os.path.join(resdir,'flood_vulnerability.gdb')
if arcpy.Exists(gdb):
    print('Geodatabase already exists')
else:
    arcpy.CreateFileGDB_management(resdir, 'flood_vulnerability.gdb')
arcpy.env.workspace = gdb

#----------------------------------
# Import data
#----------------------------------
WAdb = os.path.join(datadir, 'WAParcel\StatewideParcels_v2012_e9.2_r1.3\StatewideParcels_v2012_e9.2_r1.3.gdb')#Washington statewide parcel database
parcel = os.path.join(WAdb, 'Land\Parcel')
parcel_name = os.path.join(WAdb, 'Name')
parcel_taxroll = os.path.join(WAdb, 'TaxRoll')
parcel_taxrollname_r = os.path.join(WAdb, 'TaxRollsHaveNames')
StateLU =  os.path.join(WAdb, 'StateLandUse')

#Join taxroll attributes to parcel polygons (one-to-many relationship from parcel to taxrollIDs so require query
arcpy.MakeFeatureLayer_management(parcel, 'parcel_lyr')
try:
    SQLjoin = 'Parcel.PolyID = TaxRoll.PolyID'
    # Make Query Table...
    arcpy.MakeQueryTable_management([parcel, parcel_taxroll], 'parcel_taxroll_query', "ADD_VIRTUAL_KEY_FIELD", where_clause=SQLjoin)
except Exception as err:
    print(err.args[0])
arcpy.CopyFeatures_management('parcel_taxroll_query', 'parcel_taxroll')

#Join owner names to parcel taxroll attributes
arcpy.MakeTableView_management(parcel_taxroll, 'parcel_taxroll_lyr')
arcpy.AddJoin_management('parcel_taxroll_lyr','TaxRollID',parcel_taxrollname_r,'TaxRollID')
arcpy.AddJoin_management('parcel_taxroll_lyr','TaxRollsHaveNames.NameID',parcel_name,'NameID')
arcpy.CopyRows_management('parcel_taxroll_lyr', 'parcel_taxrollname')

#Identify residential land use codes, excluding vacation and hotels
arcpy.Exists(StateLU)
arcpy.MakeTableView_management(StateLU, 'StateLU_lyr', where_clause="Category='RESIDENTIAL'")
LUsel = {}
for row in arcpy.da.SearchCursor('StateLU_lyr',['StateLandUseCD','Name']):
    print(row[0])
    if row[1] not in ['Vacation and cabin','Hotels/motels']:
        LUsel[row[0]]=row[1]

#Only keep residential parcels
[f.name for f in arcpy.ListFields('parcel_taxrollname')]
arcpy.MakeTableView_management('parcel_taxrollname', 'parcel_taxrollname_lyr')
arcpy.SelectLayerByAttribute_management('parcel_taxrollname_lyr', 'NEW_SELECTION', '"StateLandUseCD" IN ({})'.format(', '.join(map(str, LUsel.keys())) or 'NULL'))
resid = 'parcel_taxrollname_residential'
arcpy.CopyRows_management('parcel_taxrollname_lyr', resid)

#------------------------------------------------------------------------------------------------------
# PARSE NAMES
#------------------------------------------------------------------------------------------------------
# For good guide on regex: https://docs.python.org/3/howto/regex.html

#----------------------------------------------------------------
#Only keep individual owners rather than companies or institutions
#If doesn't work, try: https://github.com/datamade/probablepeople
#For now, use a lot of suffixes used in training probable people
#Only keep individual owners rather than companies or institutions
#If doesn't work, try: https://github.com/datamade/probablepeople
#For now, use a lot of suffixes used in training probable people

#Functions to create regex patterns out of different word types: single words, abbrevations, and acronyms
def pattern_word(word, plural):
    if isinstance(word, str):
        rword = re.escape(word)
        if plural is True:
            reg_word = r'\b(' + rword + r')S?\b'
        else:
            reg_word = r'\b(' + rword + r')\b'
        return reg_word
    else:
        raise Warning('input is not a string')
def pattern_abbrev(word):
    if isinstance(word, str):
        rword = re.escape(word)
        reg_word = r'\b(' + word + r')\b[.]?'
        return reg_word
    else:
        raise Warning('input is not a string')
def pattern_acronym(word):
    if isinstance(word, str):
        rword = re.escape(word)
        reg_word = r'\s'+r'\W?'.join([i for i in word])+'([.]?[*]?\s*|\/)'
        return reg_word
    else:
        raise Warning('input is not a string')

#COMPANIES#
#Assign company names to word categories to be converted to regex pattern
private_words = ['ENTERPRISE','SHARE','COMPANY','PARTNER', 'PARTNERSHIP','PRTNRSHP','CORPORATION','MORTGAGE','INVEST[A-Z]*','ASSOCIATE',
         'BROKERAGE','COMPANY','CONSULTING','CONSULTANT','REALTY','ORGANIZATION','GROUP','SERVICE','PROPERTIY','APT',
         'APARTMENT','CONDOMINIUM','PROPERTIES','ESTATE','RANCH','HOLDING','CAPITAL','FUND','SUBSIDIARY','SUBSIDIARIES',
                 'LIMITED','ATTN','BLDG','CONSTRUCTION']
private_word_noplural = ['BANK']
private_abbrev = ['ASS','CO','CORP','INC','ORG']
private_acro = ['LTD','LP','LLP','LLC']

#Convert all words into regex patterns
private_reglist = [pattern_word(w, plural=True) for w in private_words]+\
                  [pattern_abbrev(w) for w in private_abbrev]+\
                  [pattern_acronym(w) for w in private_acro]+\
                  [pattern_word(w, plural=False) for w in private_word_noplural]
#Create an overall pattern looking for any of these patterns
private_regunion = "(" + ")|(".join(private_reglist) + ")"

#OTHER INSTITUTIONS#
inst_words = ['USA','CHURCH','DIOCESE','COUNTY','CTY','CITY','TOWN','MUNICIPAL','DISTRICT','SCHOOL','COLLEGE','UNIVERSITY','INSTITUTE',
              'LIBRARY','FOUNDATION', 'FEDERAL','SECRETARY','NATIONAL','ASSOCIATION','HOUSE','VACANT','UNION','HOSPITAL',
              'CENTER','CTR','RETIREMENT','UTILIT[A-Z]*','RESOURCE','HOME','FARM','ASSOC','POLICE','COUNCIL','OFFICE',
              'BUREAU','DEPARTMENT','DPT','STATE','CHAPTER','MARKET','TRIBE','SOCIETY','ALLIANCE','AUTHORITY','CLINIC',
              'GOVERNMENT','GOVT','COMMITTEE','LOCAL','ACADEMY','ASSEMBLY','AGENCY','GOD','MISSION','OF'] #add owners, homeowners
inst_reglist = [pattern_word(w, plural=True) for w in inst_words]+\
              [pattern_abbrev('ASSOC')]+\
              [pattern_acronym('PAC')]
inst_regunion = "(" + ")|(".join(inst_reglist) + ")"


#TRUST#
trust_words = ['TTEE','TTE','TRST','TRUSTEE', 'TRUST','GRANTEES']
trust_reglist = [pattern_word(w, plural=True) for w in trust_words]
trust_regunion = "(" + ")|(".join(trust_reglist) + ")"

######################################### PROCESSING FRONTIER ##########################################################
#Filter parcel records
# pdat_housingsub = pdat_housing[pdat_housing['PartyName'].notnull()]
# pdat_housing.shape
# #Check filtering
# pdat_housing_private = pdat_housingsub[pdat_housingsub['PartyName'].str.contains(private_regunion, regex=True, case=False)]
# pdat_housing_inst = pdat_housingsub[pdat_housingsub['PartyName'].str.contains(inst_regunion, regex=True, case=False)]
# pdat_housing_trust = pdat_housingsub[pdat_housingsub['PartyName'].str.contains(trust_regunion, regex=True, case=False)]
# pdat_housing_private.to_csv('pdat_housing_private.csv')
# pdat_housing_inst.to_csv('pdat_housing_inst.csv')
# pdat_housing_trust.to_csv('pdat_housing_trust.csv')
#
# #Filter out all non individuals
# nonindiv_filter = "|".join([private_regunion,inst_regunion,trust_regunion, ])+'|[0-9]+' #also remove any party name containing numbers
# pdat_housingindiv = pdat_housingsub[~pdat_housingsub['PartyName'].str.contains(nonindiv_filter, regex=True, case=False)]
# pdat_housingindiv.shape
#
# #To do: assess percentage of people in census removed due to keywords (e.g. town, church, etc. as last names)
#
# #Then check whether the string has &,/, or OR, if so, split it at each of these characters
# splitparty = pdat_housingindiv['PartyName'].str.split(r'[&]|\/|\\|\s{2,}|\bOR\b|\bAND\b|\bJR\b|\bSR\b|\bVS\b|\bII\b|\bIII\b', expand=True)
# newcols = ['party{}'.format(i) for i in list(range(1,splitparty.shape[1]+1))]
# pdat_housingindiv[newcols] = splitparty
# pdat_housingindiv.to_csv('pdat_housingindiv_checksplit.csv')
#
# #Divide first name by space or comma
# splitsubparty = pdat_housingindiv['party1'].str.split(r'\s(?!$)|[,]\s?|\s\bAKA\b\s', expand=True)
# newcols = ['subparty1_{}'.format(i) for i in list(range(1,splitsubparty.shape[1]+1))]
# pdat_housingindiv[newcols] = splitsubparty
# pdat_housingindiv.to_csv('pdat_housingindivparty1_checksplit.csv')
#
# #Subparty1, first column
# #Find single letter, delete content and push all subsequent columns left until first full word
# pdat_housingindiv['subparty1_{}'.format(splitsubparty.shape[1]+1)] = np.nan
#
#
# mask = pdat_housingindiv.subparty1_1.str.len() == 1 | pdat_housingindiv.subparty1_1.isnull()
# while pdat_housingindiv.loc[mask, newcols].shape[0] > 0:
#     pdat_housingindiv.loc[mask, newcols] = \
#         pdat_housingindiv.loc[mask, newcols].astype(str).shift(-1, axis=1)
# pdat_housingindiv[pdat_housingindiv[newcols].isnull().all(axis=1)]
