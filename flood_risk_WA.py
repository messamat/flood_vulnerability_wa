import arcpy
import os
from collections import defaultdict

arcpy.CheckOutExtension("Spatial")
arcpy.env.overwriteOutput = True
arcpy.env.qualifiedFieldNames = False

#Folder structure
rootdir = 'C:/Mathis/ICSL/flood_vulnerability'
datadir = os.path.join(rootdir, 'data')
resdir = os.path.join(rootdir, 'results')
gdb_vulne = os.path.join(resdir,'flood_vulnerability.gdb')

gdb = os.path.join(resdir,'flood_risk.gdb')
if arcpy.Exists(gdb):
    print('Geodatabase already exists')
else:
    arcpy.CreateFileGDB_management(resdir, 'flood_risk.gdb')
arcpy.env.workspace = gdb

#Input data variables
FEMAdata = os.path.join(datadir, 'FEMA_20180819/NFHL_53_20180620/NFHL_53_20180620.gdb')
floodhaz =  os.path.join(FEMAdata, 'S_Fld_Haz_Ar')
USadmin = 'C:\Mathis\ICSL\stormwater\data\USA_adm_gdb\USA_adm.gdb'
USstates = os.path.join(USadmin, 'USA_adm1')
censusblock2010 = 'C:\Mathis\ICSL\stormwater\data\TIGER2017\\tabblock2010_53_pophu\\tabblock2010_53_pophu.shp'

WAdb = os.path.join(datadir, 'WAParcel\StatewideParcels_v2012_e9.2_r1.3\StatewideParcels_v2012_e9.2_r1.3.gdb')#Washington statewide parcel database
parcel = os.path.join(WAdb, 'Land\Parcel')
parcel_name = os.path.join(WAdb, 'Name')
parcel_taxroll = os.path.join(WAdb, 'TaxRoll')
parcel_taxrollname_r = os.path.join(WAdb, 'TaxRollsHaveNames')
StateLU =  os.path.join(WAdb, 'StateLandUse')
provider = os.path.join(WAdb, 'DataProvider')
resid = os.path.join(gdb_vulne, 'parcel_taxrollname_residential')

#Output variables
floodhazproj = 'S_Fld_Haz_Ar_proj'

#Projection (same as WA parcel database): NAD 1983 StatePlane Washington South FIPS 4602 Feet
cs = arcpy.SpatialReference(102749)

#Project FEMA
arcpy.Project_management(floodhaz,floodhazproj, out_coor_system=cs)

#Dissolve flood hazard data to get footprint
arcpy.Dissolve_management(floodhazproj, 'floodhaz_diss',multi_part='SINGLE_PART')

#Create separate layer only with Special Flood Hazard Area (100-year flood zone)
#From https://www.fema.gov/flood-zones (do not include coastal flooding 'V', 'VE', ['V'+str(n) for n in range(1,31)]
#all_codes = set([r[0] for r in arcpy.da.SearchCursor(floodhazproj, ['FLD_ZONE'])])
SFHA_codes = ['A', 'AO','AH', 'AE', 'A99', 'AR', 'AR/AE', 'AR/AO', 'AR/A1-A30', 'AR/A']+['A'+str(n) for n in range(1,31)]
SQLsel = "{0} IN ('{1}')".format('"FLD_ZONE"',"', '".join(map(str, SFHA_codes)) or 'NULL')
arcpy.MakeFeatureLayer_management(floodhazproj, 'floodhaz_lyr')
arcpy.SelectLayerByAttribute_management('floodhaz_lyr', 'NEW_SELECTION',  SQLsel)
arcpy.CopyFeatures_management('floodhaz_lyr', 'floodhaz_SFHA')
#Create separate layer only with SFHA from detailed studies
arcpy.SelectLayerByAttribute_management('floodhaz_lyr', 'SUBSET_SELECTION', "NOT FLD_ZONE='A'")
arcpy.CopyFeatures_management('floodhaz_lyr', 'floodhaz_SFHA_detailed')

#Assess percentage of washington state with FEMA data
arcpy.MakeFeatureLayer_management(USstates, 'WAborder', "{}='Washington'".format('"NAME_1"'))
arcpy.CopyFeatures_management('WAborder', 'WA')
arcpy.Project_management('WA', 'WA_proj', out_coor_system=cs)
arcpy.AddGeometryAttributes_management('WA_proj', 'AREA', Area_Unit='SQUARE_METERS')
arcpy.AlterField_management('WA_proj', 'POLY_AREA', 'WA_AREA', 'WA_AREA')
arcpy.Intersect_analysis(['WA_proj',floodhazproj], 'WAflood_inters')
arcpy.AddGeometryAttributes_management('WAflood_inters', 'AREA', Area_Unit='SQUARE_METERS')
sum([row[0]/((10**6)*row[1]) for row in arcpy.da.SearchCursor('WAflood_inters', ['POLY_AREA','WA_AREA'])]) #FEMA flood hazard layers only cover 34% of WA

#Assess percentage of WA population living in area with FEMA data
arcpy.Project_management(censusblock2010, 'block2010_proj', out_coor_system=cs)
arcpy.AddGeometryAttributes_management('block2010_proj', 'AREA', Area_Unit='SQUARE_METERS')
arcpy.AlterField_management('block2010_proj', 'POLY_AREA', 'BLOCK_AREA', 'BLOCK_AREA')
arcpy.Intersect_analysis(['block2010_proj',floodhazproj], 'blockflood_inters')
arcpy.AddGeometryAttributes_management('blockflood_inters', 'AREA', Area_Unit='SQUARE_METERS')
WApop = sum([row[0] for row in arcpy.da.SearchCursor(censusblock2010, ['POP10'])])
WApop_FEMA = sum([row[0]*row[1]/row[2] for row in arcpy.da.SearchCursor('blockflood_inters', ['POP10','POLY_AREA','BLOCK_AREA'])])
WApop_FEMA/WApop #49% of WA population lives in an area with a FEMA assessment

#-----------------------------------------------------------------------------------------------------------------------
# DOWNSCALE CENSUS POPULATION
#-----------------------------------------------------------------------------------------------------------------------
#Remove parcels < 5m2 - cannot hold any housing, often slivers due to polygon processing
arcpy.AddGeometryAttributes_management(parcel, 'AREA', Area_Unit='SQUARE_METERS')
arcpy.MakeFeatureLayer_management(parcel, 'parcel_lyr', '"POLY_AREA">5')
arcpy.CopyFeatures_management('parcel_lyr', 'parcel_o5')

#Separate county data from other state and federal data
#Create list of data providers code
providerID = {}
for row in arcpy.da.SearchCursor(provider, ['DataProviderID','Name']):
    providerID[row[0]] = row[1]
#DNR: 640, WDFW: 641, BLM: 843
arcpy.MakeFeatureLayer_management('parcel_o5', 'parcel_o5lyr', 'NOT "DataProviderID" IN {}'.format(str(tuple([640,641,843]))))
arcpy.CopyFeatures_management('parcel_o5lyr', 'parcel_o5county')

#Check for polygons with duplicate geometry
arcpy.FindIdentical_management('parcel_o5county', 'parcel_o5county_geodupli', fields='Shape', output_record_option='ONLY_DUPLICATES')
arcpy.MakeFeatureLayer_management('parcel_o5county', 'parcel_o5county_lyr')
arcpy.AddJoin_management('parcel_o5county_lyr', 'OBJECTID', 'parcel_o5county_geodupli', 'IN_FID', join_type='KEEP_COMMON')
arcpy.CopyFeatures_management('parcel_o5county_lyr', 'parcel_o5county_geoduplipoly')

arcpy.MakeTableView_management(parcel_taxroll, 'taxroll_view')
arcpy.AddJoin_management('taxroll_view','PolyID','parcel_o5county_geoduplipoly','PolyID', join_type='KEEP_COMMON')
arcpy.CopyRows_management('taxroll_view', 'taxroll_parcel_o5county_geoduplipoly')

################## TO DO: Inspect duplicate polygons ##################################
#Make copy of parcel_o5county
parcel_nogeodupli = 'parcel_o5county_nogeodupli'
arcpy.CopyFeatures_management('parcel_o5county', parcel_nogeodupli)
#Add Field: ProcessParcelFlattened_MM
arcpy.AddField_management(parcel_nogeodupli , 'ProcessParcelFlattened_MM', field_type='SHORT')
#Add Field: ProcessParcelDuplicatesRemoved_MM
arcpy.AddField_management(parcel_nogeodupli , 'ProcessParcelDuplicatesRemoved_MM', field_type='SHORT')

polyflatten = defaultdict(list)
polyremove = defaultdict(list)
polykeep = defaultdict(list)
duplipoly_fields = ['PolyID','FEAT_SEQ','StateLandUseCD','ProcessParcelFlattened','ProcessParcelDuplicatesRemoved']
with arcpy.da.SearchCursor('taxroll_parcel_o5county_geoduplipoly', duplipoly_fields) as cursor:
    for row in cursor:
        if row[1] not in polykeep:
            polykeep[row[1]]
            #Add to polykeep
        #Else:
            #If identical aside from PolyID, TaxRollID, TaxAccountID, SourceParcelID, OBJECTID, IN_FID
                #Based on FEAT_SEQ, add PolyID and ProcessParcelDuplicatesRemoved to polyremove
            #If not identical:
                #If same PolyID, skip
                #If ProcessParcelFlattened > that in dictionary:
                    #Add that in polykeep to polyflatten
                    #Replace in polykeep with current one
                #Else
                    #Add current one to polyflatten

#Cursor to change in parcel
#Cursor to change in taxroll


#If duplicate:
    #If same TaxRoll records:
        #Delete polygon based on PolyID
        #Add to ProcessParcelDuplicatesRemoved
    #If different TaxRoll records:
        #Change polyID to the same in parcel
        #Change polyID in TaxRoll as well
        #Add to ProcessParcelFlattened


#If ProcessParcelFlattened not null for one and null for the other(s):
    #Assign ProcessParcelFlattened_MM=1 to PolyID if null, otherwise ProcessParcelFlattened_MM=ProcessParcelFlattened
    #Keep PolyID with highest ProcessParcelFlattened and add the value of PPF from other PolyID to ProcessParcelFlattened_MM
#If ProcessParcelDuplicatesRemoved not null for either:
    #Assign ProcessParcelDuplicatesRemoved_MM=1 to PolyID if null, otherwise ProcessParcelDuplicatesRemoved_MM=ProcessParcelDuplicatesRemoved
    #Keep PolyID with highest ProcessParcelDuplicatesRemoved and add the value of PPDR from other PolyID to ProcessParcelDuplicatesRemoved_MM
#If neither ProcessParcelDuplicatesRemoved nor ProcessParcelFlattened have values
    #Check if identical aside from PolyID, TaxRollID, TaxAccountID, SourceParcelID, OBJECTID, IN_FID
        #If so, delete one and add 2 to ProcessParcelDuplicatesRemoved
    #Otherwise,
        #Delete one and add 2 to ProcessParcelFlattened

##################DETECT INTERSECTING POLYGONS###################


##################INSPECT DUPLICATE POLYID IN TAXROLL############
# Check for ProcessParcelFlattened

#Check which of:
    #TabularAcre of each individual record or sum of all records best matches polygon area
#If no tabular acres and single family:
    # check highest total value (in order): TaxableValueTotal, TaxableValueImprovements+TaxableValueLand, MarketValueTotal,
    #    MarketValueImprovements, MarketValueLand
    # check whether tabular acre even remotely close to POLY_AREA

#If other than single family:
    #Check if # in ProcessParcelFlattened+1 matches number of records


#---------------Method 1: downscale census block population based on parcel area----------------------------------------
#Intersect parcel with census block population

#---------------Method 2: downscale census block population based on impervious area within parcel----------------------
    #Get US NAIP land cover data
    #With impervious area
    #Without impervious area: lower 10th percentile of block of same size?

#---------------Method 3: downscale census block population based on parcel information---------------------------------
    #When duplicate PolyID, add number of duplicates as usually due to e.g. multiple condos within condo unit
    #Get number of units from LanduSeCD
    #Get unit size from Improvement?
    #Get number of rooms from Improvement?
    #Get construction year + renovation year

    #Residential areas without unit size or number of rooms







#Join taxroll attributes to parcel polygons (one-to-many relationship from parcel to taxrollIDs so require query
arcpy.MakeFeatureLayer_management(parcel, 'parcel_lyr')
try:
    SQLjoin = 'Parcel.PolyID = TaxRoll.PolyID'
    # Make Query Table...
    arcpy.MakeQueryTable_management([parcel, parcel_taxroll], 'parcel_taxroll_query', "ADD_VIRTUAL_KEY_FIELD", where_clause=SQLjoin)
except Exception as err:
    print(err.args[0])
arcpy.CopyFeatures_management('parcel_taxroll_query', 'parcel_taxroll')